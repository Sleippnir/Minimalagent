import {
  require_jsx_runtime
} from "./chunk-PMZ3ULIR.js";
import {
  $c0d10c4690969999$export$e4036f9b8ddb7379,
  $c1b4da4af54f4fa1$export$6b4624d233c61fcb
} from "./chunk-R2INV3AV.js";
import {
  require_react
} from "./chunk-KQPGYOHB.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@pipecat-ai/client-react/dist/index.module.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());

// node_modules/jotai/esm/vanilla/internals.mjs
function hasInitialValue(atom2) {
  return "init" in atom2;
}
function isActuallyWritableAtom(atom2) {
  return !!atom2.write;
}
function isAtomStateInitialized(atomState) {
  return "v" in atomState || "e" in atomState;
}
function returnAtomValue(atomState) {
  if ("e" in atomState) {
    throw atomState.e;
  }
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("v" in atomState)) {
    throw new Error("[Bug] atom state is not initialized");
  }
  return atomState.v;
}
var promiseStateMap = /* @__PURE__ */ new WeakMap();
function isPendingPromise(value) {
  var _a;
  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);
}
function abortPromise(promise) {
  const promiseState = promiseStateMap.get(promise);
  if (promiseState == null ? void 0 : promiseState[0]) {
    promiseState[0] = false;
    promiseState[1].forEach((fn) => fn());
  }
}
function registerAbortHandler(promise, abortHandler) {
  let promiseState = promiseStateMap.get(promise);
  if (!promiseState) {
    promiseState = [true, /* @__PURE__ */ new Set()];
    promiseStateMap.set(promise, promiseState);
    const settle = () => {
      promiseState[0] = false;
    };
    promise.then(settle, settle);
  }
  promiseState[1].add(abortHandler);
}
function isPromiseLike(p) {
  return typeof (p == null ? void 0 : p.then) === "function";
}
function addPendingPromiseToDependency(atom2, promise, dependencyAtomState) {
  if (!dependencyAtomState.p.has(atom2)) {
    dependencyAtomState.p.add(atom2);
    const cleanup = () => dependencyAtomState.p.delete(atom2);
    promise.then(cleanup, cleanup);
  }
}
function getMountedOrPendingDependents(atom2, atomState, mountedMap) {
  var _a;
  const dependents = /* @__PURE__ */ new Set();
  for (const a of ((_a = mountedMap.get(atom2)) == null ? void 0 : _a.t) || []) {
    if (mountedMap.has(a)) {
      dependents.add(a);
    }
  }
  for (const atomWithPendingPromise of atomState.p) {
    dependents.add(atomWithPendingPromise);
  }
  return dependents;
}
var atomRead = (_store, atom2, ...params) => atom2.read(...params);
var atomWrite = (_store, atom2, ...params) => atom2.write(...params);
var atomOnInit = (store, atom2) => {
  var _a;
  return (_a = atom2.unstable_onInit) == null ? void 0 : _a.call(atom2, store);
};
var atomOnMount = (_store, atom2, setAtom) => {
  var _a;
  return (_a = atom2.onMount) == null ? void 0 : _a.call(atom2, setAtom);
};
var ensureAtomState = (store, atom2) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const atomStateMap = buildingBlocks[0];
  const atomOnInit2 = buildingBlocks[9];
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !atom2) {
    throw new Error("Atom is undefined or null");
  }
  let atomState = atomStateMap.get(atom2);
  if (!atomState) {
    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };
    atomStateMap.set(atom2, atomState);
    atomOnInit2 == null ? void 0 : atomOnInit2(store, atom2);
  }
  return atomState;
};
var flushCallbacks = (store) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const changedAtoms = buildingBlocks[3];
  const mountCallbacks = buildingBlocks[4];
  const unmountCallbacks = buildingBlocks[5];
  const storeHooks = buildingBlocks[6];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const errors = [];
  const call = (fn) => {
    try {
      fn();
    } catch (e) {
      errors.push(e);
    }
  };
  do {
    if (storeHooks.f) {
      call(storeHooks.f);
    }
    const callbacks = /* @__PURE__ */ new Set();
    const add = callbacks.add.bind(callbacks);
    changedAtoms.forEach((atom2) => {
      var _a;
      return (_a = mountedMap.get(atom2)) == null ? void 0 : _a.l.forEach(add);
    });
    changedAtoms.clear();
    unmountCallbacks.forEach(add);
    unmountCallbacks.clear();
    mountCallbacks.forEach(add);
    mountCallbacks.clear();
    callbacks.forEach(call);
    if (changedAtoms.size) {
      recomputeInvalidatedAtoms2(store);
    }
  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);
  if (errors.length) {
    throw new AggregateError(errors);
  }
};
var recomputeInvalidatedAtoms = (store) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const invalidatedAtoms = buildingBlocks[2];
  const changedAtoms = buildingBlocks[3];
  const ensureAtomState2 = buildingBlocks[11];
  const readAtomState2 = buildingBlocks[14];
  const mountDependencies2 = buildingBlocks[17];
  const topSortedReversed = [];
  const visiting = /* @__PURE__ */ new WeakSet();
  const visited = /* @__PURE__ */ new WeakSet();
  const stack = Array.from(changedAtoms);
  while (stack.length) {
    const a = stack[stack.length - 1];
    const aState = ensureAtomState2(store, a);
    if (visited.has(a)) {
      stack.pop();
      continue;
    }
    if (visiting.has(a)) {
      if (invalidatedAtoms.get(a) === aState.n) {
        topSortedReversed.push([a, aState]);
      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && invalidatedAtoms.has(a)) {
        throw new Error("[Bug] invalidated atom exists");
      }
      visited.add(a);
      stack.pop();
      continue;
    }
    visiting.add(a);
    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
      if (!visiting.has(d)) {
        stack.push(d);
      }
    }
  }
  for (let i = topSortedReversed.length - 1; i >= 0; --i) {
    const [a, aState] = topSortedReversed[i];
    let hasChangedDeps = false;
    for (const dep of aState.d.keys()) {
      if (dep !== a && changedAtoms.has(dep)) {
        hasChangedDeps = true;
        break;
      }
    }
    if (hasChangedDeps) {
      readAtomState2(store, a);
      mountDependencies2(store, a);
    }
    invalidatedAtoms.delete(a);
  }
};
var readAtomState = (store, atom2) => {
  var _a, _b;
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const invalidatedAtoms = buildingBlocks[2];
  const changedAtoms = buildingBlocks[3];
  const storeHooks = buildingBlocks[6];
  const atomRead2 = buildingBlocks[7];
  const ensureAtomState2 = buildingBlocks[11];
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const readAtomState2 = buildingBlocks[14];
  const writeAtomState2 = buildingBlocks[16];
  const mountDependencies2 = buildingBlocks[17];
  const atomState = ensureAtomState2(store, atom2);
  if (isAtomStateInitialized(atomState)) {
    if (mountedMap.has(atom2) && invalidatedAtoms.get(atom2) !== atomState.n) {
      return atomState;
    }
    if (Array.from(atomState.d).every(
      ([a, n]) => (
        // Recursively, read the atom state of the dependency, and
        // check if the atom epoch number is unchanged
        readAtomState2(store, a).n === n
      )
    )) {
      return atomState;
    }
  }
  atomState.d.clear();
  let isSync = true;
  function mountDependenciesIfAsync() {
    if (mountedMap.has(atom2)) {
      mountDependencies2(store, atom2);
      recomputeInvalidatedAtoms2(store);
      flushCallbacks2(store);
    }
  }
  function getter(a) {
    var _a2;
    if (a === atom2) {
      const aState2 = ensureAtomState2(store, a);
      if (!isAtomStateInitialized(aState2)) {
        if (hasInitialValue(a)) {
          setAtomStateValueOrPromise(store, a, a.init);
        } else {
          throw new Error("no atom init");
        }
      }
      return returnAtomValue(aState2);
    }
    const aState = readAtomState2(store, a);
    try {
      return returnAtomValue(aState);
    } finally {
      atomState.d.set(a, aState.n);
      if (isPendingPromise(atomState.v)) {
        addPendingPromiseToDependency(atom2, atomState.v, aState);
      }
      (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom2);
      if (!isSync) {
        mountDependenciesIfAsync();
      }
    }
  }
  let controller;
  let setSelf;
  const options = {
    get signal() {
      if (!controller) {
        controller = new AbortController();
      }
      return controller.signal;
    },
    get setSelf() {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
        console.warn("setSelf function cannot be used with read-only atom");
      }
      if (!setSelf && isActuallyWritableAtom(atom2)) {
        setSelf = (...args) => {
          if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && isSync) {
            console.warn("setSelf function cannot be called in sync");
          }
          if (!isSync) {
            try {
              return writeAtomState2(store, atom2, ...args);
            } finally {
              recomputeInvalidatedAtoms2(store);
              flushCallbacks2(store);
            }
          }
        };
      }
      return setSelf;
    }
  };
  const prevEpochNumber = atomState.n;
  try {
    const valueOrPromise = atomRead2(store, atom2, getter, options);
    setAtomStateValueOrPromise(store, atom2, valueOrPromise);
    if (isPromiseLike(valueOrPromise)) {
      registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());
      valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);
    }
    (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom2);
    return atomState;
  } catch (error) {
    delete atomState.v;
    atomState.e = error;
    ++atomState.n;
    return atomState;
  } finally {
    isSync = false;
    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom2) === prevEpochNumber) {
      invalidatedAtoms.set(atom2, atomState.n);
      changedAtoms.add(atom2);
      (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom2);
    }
  }
};
var invalidateDependents = (store, atom2) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const invalidatedAtoms = buildingBlocks[2];
  const ensureAtomState2 = buildingBlocks[11];
  const stack = [atom2];
  while (stack.length) {
    const a = stack.pop();
    const aState = ensureAtomState2(store, a);
    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {
      const dState = ensureAtomState2(store, d);
      invalidatedAtoms.set(d, dState.n);
      stack.push(d);
    }
  }
};
var writeAtomState = (store, atom2, ...args) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const changedAtoms = buildingBlocks[3];
  const storeHooks = buildingBlocks[6];
  const atomWrite2 = buildingBlocks[8];
  const ensureAtomState2 = buildingBlocks[11];
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const readAtomState2 = buildingBlocks[14];
  const invalidateDependents2 = buildingBlocks[15];
  const mountDependencies2 = buildingBlocks[17];
  let isSync = true;
  const getter = (a) => returnAtomValue(readAtomState2(store, a));
  const setter = (a, ...args2) => {
    var _a;
    const aState = ensureAtomState2(store, a);
    try {
      if (a === atom2) {
        if (!hasInitialValue(a)) {
          throw new Error("atom not writable");
        }
        const prevEpochNumber = aState.n;
        const v = args2[0];
        setAtomStateValueOrPromise(store, a, v);
        mountDependencies2(store, a);
        if (prevEpochNumber !== aState.n) {
          changedAtoms.add(a);
          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
          invalidateDependents2(store, a);
        }
        return void 0;
      } else {
        return writeAtomState(store, a, ...args2);
      }
    } finally {
      if (!isSync) {
        recomputeInvalidatedAtoms2(store);
        flushCallbacks2(store);
      }
    }
  };
  try {
    return atomWrite2(store, atom2, getter, setter, ...args);
  } finally {
    isSync = false;
  }
};
var mountDependencies = (store, atom2) => {
  var _a;
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const changedAtoms = buildingBlocks[3];
  const storeHooks = buildingBlocks[6];
  const ensureAtomState2 = buildingBlocks[11];
  const invalidateDependents2 = buildingBlocks[15];
  const mountAtom2 = buildingBlocks[18];
  const unmountAtom2 = buildingBlocks[19];
  const atomState = ensureAtomState2(store, atom2);
  const mounted = mountedMap.get(atom2);
  if (mounted && !isPendingPromise(atomState.v)) {
    for (const [a, n] of atomState.d) {
      if (!mounted.d.has(a)) {
        const aState = ensureAtomState2(store, a);
        const aMounted = mountAtom2(store, a);
        aMounted.t.add(atom2);
        mounted.d.add(a);
        if (n !== aState.n) {
          changedAtoms.add(a);
          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);
          invalidateDependents2(store, a);
        }
      }
    }
    for (const a of mounted.d || []) {
      if (!atomState.d.has(a)) {
        mounted.d.delete(a);
        const aMounted = unmountAtom2(store, a);
        aMounted == null ? void 0 : aMounted.t.delete(atom2);
      }
    }
  }
};
var mountAtom = (store, atom2) => {
  var _a;
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const mountCallbacks = buildingBlocks[4];
  const storeHooks = buildingBlocks[6];
  const atomOnMount2 = buildingBlocks[10];
  const ensureAtomState2 = buildingBlocks[11];
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const readAtomState2 = buildingBlocks[14];
  const writeAtomState2 = buildingBlocks[16];
  const atomState = ensureAtomState2(store, atom2);
  let mounted = mountedMap.get(atom2);
  if (!mounted) {
    readAtomState2(store, atom2);
    for (const a of atomState.d.keys()) {
      const aMounted = mountAtom(store, a);
      aMounted.t.add(atom2);
    }
    mounted = {
      l: /* @__PURE__ */ new Set(),
      d: new Set(atomState.d.keys()),
      t: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom2, mounted);
    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom2);
    if (isActuallyWritableAtom(atom2)) {
      const processOnMount = () => {
        let isSync = true;
        const setAtom = (...args) => {
          try {
            return writeAtomState2(store, atom2, ...args);
          } finally {
            if (!isSync) {
              recomputeInvalidatedAtoms2(store);
              flushCallbacks2(store);
            }
          }
        };
        try {
          const onUnmount = atomOnMount2(store, atom2, setAtom);
          if (onUnmount) {
            mounted.u = () => {
              isSync = true;
              try {
                onUnmount();
              } finally {
                isSync = false;
              }
            };
          }
        } finally {
          isSync = false;
        }
      };
      mountCallbacks.add(processOnMount);
    }
  }
  return mounted;
};
var unmountAtom = (store, atom2) => {
  var _a;
  const buildingBlocks = getInternalBuildingBlocks(store);
  const mountedMap = buildingBlocks[1];
  const unmountCallbacks = buildingBlocks[5];
  const storeHooks = buildingBlocks[6];
  const ensureAtomState2 = buildingBlocks[11];
  const unmountAtom2 = buildingBlocks[19];
  const atomState = ensureAtomState2(store, atom2);
  let mounted = mountedMap.get(atom2);
  if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {
    var _a2;
    return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom2);
  })) {
    if (mounted.u) {
      unmountCallbacks.add(mounted.u);
    }
    mounted = void 0;
    mountedMap.delete(atom2);
    (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom2);
    for (const a of atomState.d.keys()) {
      const aMounted = unmountAtom2(store, a);
      aMounted == null ? void 0 : aMounted.t.delete(atom2);
    }
    return void 0;
  }
  return mounted;
};
var setAtomStateValueOrPromise = (store, atom2, valueOrPromise) => {
  const ensureAtomState2 = getInternalBuildingBlocks(store)[11];
  const atomState = ensureAtomState2(store, atom2);
  const hasPrevValue = "v" in atomState;
  const prevValue = atomState.v;
  if (isPromiseLike(valueOrPromise)) {
    for (const a of atomState.d.keys()) {
      addPendingPromiseToDependency(
        atom2,
        valueOrPromise,
        ensureAtomState2(store, a)
      );
    }
  }
  atomState.v = valueOrPromise;
  delete atomState.e;
  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
    ++atomState.n;
    if (isPromiseLike(prevValue)) {
      abortPromise(prevValue);
    }
  }
};
var storeGet = (store, atom2) => {
  const readAtomState2 = getInternalBuildingBlocks(store)[14];
  return returnAtomValue(readAtomState2(store, atom2));
};
var storeSet = (store, atom2, ...args) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const flushCallbacks2 = buildingBlocks[12];
  const recomputeInvalidatedAtoms2 = buildingBlocks[13];
  const writeAtomState2 = buildingBlocks[16];
  try {
    return writeAtomState2(store, atom2, ...args);
  } finally {
    recomputeInvalidatedAtoms2(store);
    flushCallbacks2(store);
  }
};
var storeSub = (store, atom2, listener) => {
  const buildingBlocks = getInternalBuildingBlocks(store);
  const flushCallbacks2 = buildingBlocks[12];
  const mountAtom2 = buildingBlocks[18];
  const unmountAtom2 = buildingBlocks[19];
  const mounted = mountAtom2(store, atom2);
  const listeners = mounted.l;
  listeners.add(listener);
  flushCallbacks2(store);
  return () => {
    listeners.delete(listener);
    unmountAtom2(store, atom2);
    flushCallbacks2(store);
  };
};
var buildingBlockMap = /* @__PURE__ */ new WeakMap();
var getInternalBuildingBlocks = (store) => {
  const buildingBlocks = buildingBlockMap.get(store);
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !buildingBlocks) {
    throw new Error(
      "Store must be created by buildStore to read its building blocks"
    );
  }
  return buildingBlocks;
};
function buildStore(...buildArgs) {
  const store = {
    get(atom2) {
      const storeGet2 = getInternalBuildingBlocks(store)[21];
      return storeGet2(store, atom2);
    },
    set(atom2, ...args) {
      const storeSet2 = getInternalBuildingBlocks(store)[22];
      return storeSet2(store, atom2, ...args);
    },
    sub(atom2, listener) {
      const storeSub2 = getInternalBuildingBlocks(store)[23];
      return storeSub2(store, atom2, listener);
    }
  };
  const buildingBlocks = [
    // store state
    /* @__PURE__ */ new WeakMap(),
    // atomStateMap
    /* @__PURE__ */ new WeakMap(),
    // mountedMap
    /* @__PURE__ */ new WeakMap(),
    // invalidatedAtoms
    /* @__PURE__ */ new Set(),
    // changedAtoms
    /* @__PURE__ */ new Set(),
    // mountCallbacks
    /* @__PURE__ */ new Set(),
    // unmountCallbacks
    {},
    // storeHooks
    // atom interceptors
    atomRead,
    atomWrite,
    atomOnInit,
    atomOnMount,
    // building-block functions
    ensureAtomState,
    flushCallbacks,
    recomputeInvalidatedAtoms,
    readAtomState,
    invalidateDependents,
    writeAtomState,
    mountDependencies,
    mountAtom,
    unmountAtom,
    setAtomStateValueOrPromise,
    storeGet,
    storeSet,
    storeSub,
    void 0
  ].map((fn, i) => buildArgs[i] || fn);
  buildingBlockMap.set(store, Object.freeze(buildingBlocks));
  return store;
}

// node_modules/jotai/esm/vanilla.mjs
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString() {
      return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && this.debugLabel ? key + ":" + this.debugLabel : key;
    }
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = defaultRead;
    config.write = defaultWrite;
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function defaultRead(get) {
  return get(this);
}
function defaultWrite(get, set, arg) {
  return set(
    this,
    typeof arg === "function" ? arg(get(this)) : arg
  );
}
var overiddenCreateStore;
function createStore() {
  if (overiddenCreateStore) {
    return overiddenCreateStore();
  }
  return buildStore();
}
var defaultStore;
function getDefaultStore() {
  if (!defaultStore) {
    defaultStore = createStore();
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
    }
  }
  return defaultStore;
}

// node_modules/jotai/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var StoreContext = (0, import_react.createContext)(
  void 0
);
function useStore(options) {
  const store = (0, import_react.useContext)(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
}
function Provider({
  children,
  store
}) {
  const storeRef = (0, import_react.useRef)(void 0);
  if (!store && !storeRef.current) {
    storeRef.current = createStore();
  }
  return (0, import_react.createElement)(
    StoreContext.Provider,
    {
      value: store || storeRef.current
    },
    children
  );
}
var isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === "function";
var attachPromiseStatus = (promise) => {
  if (!promise.status) {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
  }
};
var use = import_react.default.use || // A shim for older React versions
((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    attachPromiseStatus(promise);
    throw promise;
  }
});
var continuablePromiseMap = /* @__PURE__ */ new WeakMap();
var createContinuablePromise = (promise, getValue) => {
  let continuablePromise = continuablePromiseMap.get(promise);
  if (!continuablePromise) {
    continuablePromise = new Promise((resolve, reject) => {
      let curr = promise;
      const onFulfilled = (me) => (v) => {
        if (curr === me) {
          resolve(v);
        }
      };
      const onRejected = (me) => (e) => {
        if (curr === me) {
          reject(e);
        }
      };
      const onAbort = () => {
        try {
          const nextValue = getValue();
          if (isPromiseLike2(nextValue)) {
            continuablePromiseMap.set(nextValue, continuablePromise);
            curr = nextValue;
            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
            registerAbortHandler(nextValue, onAbort);
          } else {
            resolve(nextValue);
          }
        } catch (e) {
          reject(e);
        }
      };
      promise.then(onFulfilled(promise), onRejected(promise));
      registerAbortHandler(promise, onAbort);
    });
    continuablePromiseMap.set(promise, continuablePromise);
  }
  return continuablePromise;
};
function useAtomValue(atom2, options) {
  const { delay, unstable_promiseStatus: promiseStatus = !import_react.default.use } = options || {};
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  (0, import_react.useEffect)(() => {
    const unsub = store.sub(atom2, () => {
      if (promiseStatus) {
        try {
          const value2 = store.get(atom2);
          if (isPromiseLike2(value2)) {
            attachPromiseStatus(
              createContinuablePromise(value2, () => store.get(atom2))
            );
          }
        } catch (e) {
        }
      }
      if (typeof delay === "number") {
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay, promiseStatus]);
  (0, import_react.useDebugValue)(value);
  if (isPromiseLike2(value)) {
    const promise = createContinuablePromise(value, () => store.get(atom2));
    if (promiseStatus) {
      attachPromiseStatus(promise);
    }
    return use(promise);
  }
  return value;
}
function useSetAtom(atom2, options) {
  const store = useStore(options);
  const setAtom = (0, import_react.useCallback)(
    (...args) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}

// node_modules/jotai/esm/vanilla/utils.mjs
var RESET = Symbol(
  (import.meta.env ? import.meta.env.MODE : void 0) !== "production" ? "RESET" : ""
);
function atomFamily(initializeAtom, areEqual) {
  let shouldRemove = null;
  const atoms = /* @__PURE__ */ new Map();
  const listeners = /* @__PURE__ */ new Set();
  const createAtom = (param) => {
    let item;
    if (areEqual === void 0) {
      item = atoms.get(param);
    } else {
      for (const [key, value] of atoms) {
        if (areEqual(key, param)) {
          item = value;
          break;
        }
      }
    }
    if (item !== void 0) {
      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {
        createAtom.remove(param);
      } else {
        return item[0];
      }
    }
    const newAtom = initializeAtom(param);
    atoms.set(param, [newAtom, Date.now()]);
    notifyListeners("CREATE", param, newAtom);
    return newAtom;
  };
  const notifyListeners = (type, param, atom2) => {
    for (const listener of listeners) {
      listener({ type, param, atom: atom2 });
    }
  };
  createAtom.unstable_listen = (callback) => {
    listeners.add(callback);
    return () => {
      listeners.delete(callback);
    };
  };
  createAtom.getParams = () => atoms.keys();
  createAtom.remove = (param) => {
    if (areEqual === void 0) {
      if (!atoms.has(param)) return;
      const [atom2] = atoms.get(param);
      atoms.delete(param);
      notifyListeners("REMOVE", param, atom2);
    } else {
      for (const [key, [atom2]] of atoms) {
        if (areEqual(key, param)) {
          atoms.delete(key);
          notifyListeners("REMOVE", key, atom2);
          break;
        }
      }
    }
  };
  createAtom.setShouldRemove = (fn) => {
    shouldRemove = fn;
    if (!shouldRemove) return;
    for (const [key, [atom2, createdAt]] of atoms) {
      if (shouldRemove(createdAt, key)) {
        atoms.delete(key);
        notifyListeners("REMOVE", key, atom2);
      }
    }
  };
  return createAtom;
}
var isPromiseLike$3 = (x) => typeof (x == null ? void 0 : x.then) === "function";
function createJSONStorage(getStringStorage = () => {
  try {
    return window.localStorage;
  } catch (e) {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      if (typeof window !== "undefined") {
        console.warn(e);
      }
    }
    return void 0;
  }
}, options) {
  var _a;
  let lastStr;
  let lastValue;
  const storage = {
    getItem: (key, initialValue) => {
      var _a2, _b;
      const parse = (str2) => {
        str2 = str2 || "";
        if (lastStr !== str2) {
          try {
            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);
          } catch (e) {
            return initialValue;
          }
          lastStr = str2;
        }
        return lastValue;
      };
      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;
      if (isPromiseLike$3(str)) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (key, newValue) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(
        key,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      );
    },
    removeItem: (key) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);
    }
  };
  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {
    let newValue;
    try {
      newValue = JSON.parse(v || "");
    } catch (e) {
      newValue = initialValue;
    }
    callback(newValue);
  });
  let subscriber;
  try {
    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;
  } catch (e) {
  }
  if (!subscriber && typeof window !== "undefined" && typeof window.addEventListener === "function" && window.Storage) {
    subscriber = (key, callback) => {
      if (!(getStringStorage() instanceof window.Storage)) {
        return () => {
        };
      }
      const storageEventCallback = (e) => {
        if (e.storageArea === getStringStorage() && e.key === key) {
          callback(e.newValue);
        }
      };
      window.addEventListener("storage", storageEventCallback);
      return () => {
        window.removeEventListener("storage", storageEventCallback);
      };
    };
  }
  if (subscriber) {
    storage.subscribe = createHandleSubscribe(subscriber);
  }
  return storage;
}
var defaultStorage = createJSONStorage();

// node_modules/jotai/esm/react/utils.mjs
var import_react2 = __toESM(require_react(), 1);
function useAtomCallback(callback, options) {
  const anAtom = (0, import_react2.useMemo)(
    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),
    [callback]
  );
  return useSetAtom(anAtom, options);
}

// node_modules/@pipecat-ai/client-react/dist/index.module.js
var $ad20387e24e513d4$exports = {};
$ad20387e24e513d4$exports = JSON.parse(`{"name":"@pipecat-ai/client-react","version":"1.0.1","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"src/index.ts","repository":{"type":"git","url":"git+https://github.com/pipecat-ai/pipecat-client-web.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"parcel build --no-cache","dev":"parcel watch","lint":"eslint . --report-unused-disable-directives --max-warnings 0 --ignore-pattern 'dist/'"},"devDependencies":{"@pipecat-ai/client-js":"*","@types/react":"^18.3.3","@types/react-dom":"^18.3.0","@typescript-eslint/eslint-plugin":"^8.32.0","eslint":"^9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-react-hooks":"^5.2.0","eslint-plugin-simple-import-sort":"^12.1.1","parcel":"^2.12.0","react":"^18.3.1","react-dom":"^18.3.1","typescript":"^5.2.2"},"peerDependencies":{"@pipecat-ai/client-js":"*","react":">=18","react-dom":">=18"},"dependencies":{"jotai":"^2.9.0"}}`);
var $33f16f27e37c90bc$export$fe23d0ef95286467 = (0, import_react4.createContext)({
  on: () => {
  },
  off: () => {
  }
});
var $824ea64b5f757259$export$33a6ac53b8f02625 = (event, handler) => {
  const { on, off } = (0, import_react4.useContext)((0, $33f16f27e37c90bc$export$fe23d0ef95286467));
  (0, import_react4.useEffect)(() => {
    on(event, handler);
    return () => {
      off(event, handler);
    };
  }, [
    event,
    handler,
    on,
    off
  ]);
};
var $a90aa7250c094218$export$d6bdcccacef16204 = (0, import_react4.createContext)({
  enableCam: () => {
    throw new Error("PipecatClientCamStateContext: enableCam() called outside of provider");
  },
  isCamEnabled: false
});
var $a90aa7250c094218$export$802b42df0e0d8153 = (0, import_react4.createContext)({
  enableMic: () => {
    throw new Error("PipecatClientMicStateContext: enableMic() called outside of provider");
  },
  isMicEnabled: false
});
var $a90aa7250c094218$export$db79fdf85ddd6b65 = (0, import_react4.createContext)("disconnected");
var $a90aa7250c094218$export$4777554fda61c378 = ({ children }) => {
  const client = (0, $034a56e7ee1b7bed$export$777fa8498be78705)();
  const [isCamEnabled, setIsCamEnabled] = (0, import_react4.useState)(false);
  const [isMicEnabled, setIsMicEnabled] = (0, import_react4.useState)(false);
  const [transportState, setTransportState] = (0, import_react4.useState)("disconnected");
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TransportStateChanged, (state) => {
    setTransportState(state);
    if (state === "initialized" && client) {
      setIsCamEnabled(client.isCamEnabled ?? false);
      setIsMicEnabled(client.isMicEnabled ?? false);
    }
  });
  const enableCam = (0, import_react4.useCallback)((enabled) => {
    setIsCamEnabled(enabled);
    client?.enableCam?.(enabled);
  }, [
    client
  ]);
  const enableMic = (0, import_react4.useCallback)((enabled) => {
    setIsMicEnabled(enabled);
    client?.enableMic?.(enabled);
  }, [
    client
  ]);
  return (0, import_jsx_runtime.jsx)($a90aa7250c094218$export$db79fdf85ddd6b65.Provider, {
    value: transportState,
    children: (0, import_jsx_runtime.jsx)($a90aa7250c094218$export$d6bdcccacef16204.Provider, {
      value: {
        enableCam,
        isCamEnabled
      },
      children: (0, import_jsx_runtime.jsx)($a90aa7250c094218$export$802b42df0e0d8153.Provider, {
        value: {
          enableMic,
          isMicEnabled
        },
        children
      })
    })
  });
};
var $d2e362c5a07ee3c5$var$defaultStore = (0, createStore)();
var $d2e362c5a07ee3c5$export$67f6d73bc6cd7bb1 = (0, import_react4.createContext)({});
var $d2e362c5a07ee3c5$export$bb43666ced7a20d0 = ({ children, client, jotaiStore = $d2e362c5a07ee3c5$var$defaultStore }) => {
  (0, import_react4.useEffect)(() => {
    (0, $c0d10c4690969999$export$e4036f9b8ddb7379)({
      library: (0, $ad20387e24e513d4$exports.name),
      library_version: (0, $ad20387e24e513d4$exports.version)
    });
  }, []);
  const eventHandlersMap = (0, import_react4.useRef)({});
  (0, import_react4.useEffect)(() => {
    if (!client) return;
    const allEvents = Object.values((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb)).filter((value) => isNaN(Number(value)));
    const allHandlers = {};
    allEvents.forEach((event) => {
      const handler = (...payload) => {
        const handlers = eventHandlersMap.current[event];
        if (!handlers) return;
        handlers.forEach((h) => {
          h(...payload);
        });
      };
      allHandlers[event] = handler;
      client.on(event, handler);
    });
    return () => {
      allEvents.forEach((event) => {
        client.off(event, allHandlers[event]);
      });
    };
  }, [
    client
  ]);
  const on = (0, import_react4.useCallback)((event, handler) => {
    if (!eventHandlersMap.current[event]) eventHandlersMap.current[event] = /* @__PURE__ */ new Set();
    eventHandlersMap.current[event].add(handler);
  }, []);
  const off = (0, import_react4.useCallback)((event, handler) => {
    eventHandlersMap.current[event]?.delete(handler);
  }, []);
  return (0, import_jsx_runtime.jsx)((0, Provider), {
    store: jotaiStore,
    children: (0, import_jsx_runtime.jsx)($d2e362c5a07ee3c5$export$67f6d73bc6cd7bb1.Provider, {
      value: {
        client
      },
      children: (0, import_jsx_runtime.jsx)((0, $33f16f27e37c90bc$export$fe23d0ef95286467).Provider, {
        value: {
          on,
          off
        },
        children: (0, import_jsx_runtime.jsx)((0, $a90aa7250c094218$export$4777554fda61c378), {
          children
        })
      })
    })
  });
};
$d2e362c5a07ee3c5$export$bb43666ced7a20d0.displayName = "PipecatClientProvider";
var $034a56e7ee1b7bed$export$777fa8498be78705 = () => {
  const { client } = (0, import_react4.useContext)((0, $d2e362c5a07ee3c5$export$67f6d73bc6cd7bb1));
  return client;
};
var $4b4b9099cdb5b776$var$localAudioTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$localVideoTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$localScreenAudioTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$localScreenVideoTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$botAudioTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$botVideoTrackAtom = (0, atom)(null);
var $4b4b9099cdb5b776$var$trackAtom = (0, atomFamily)(({ local, trackType }) => {
  if (local) switch (trackType) {
    case "audio":
      return $4b4b9099cdb5b776$var$localAudioTrackAtom;
    case "screenAudio":
      return $4b4b9099cdb5b776$var$localScreenAudioTrackAtom;
    case "screenVideo":
      return $4b4b9099cdb5b776$var$localScreenVideoTrackAtom;
    case "video":
      return $4b4b9099cdb5b776$var$localVideoTrackAtom;
  }
  return trackType === "audio" ? $4b4b9099cdb5b776$var$botAudioTrackAtom : $4b4b9099cdb5b776$var$botVideoTrackAtom;
});
var $4b4b9099cdb5b776$export$9813dcd2d0c26814 = (trackType, participantType) => {
  const client = (0, $034a56e7ee1b7bed$export$777fa8498be78705)();
  const track = (0, useAtomValue)($4b4b9099cdb5b776$var$trackAtom({
    local: participantType === "local",
    trackType
  }));
  const updateTrack = (0, useAtomCallback)((0, import_react4.useCallback)((get, set, track2, trackType2, local) => {
    const atom2 = $4b4b9099cdb5b776$var$trackAtom({
      local,
      trackType: trackType2
    });
    const oldTrack = get(atom2);
    if (oldTrack?.id === track2.id) return;
    set(atom2, track2);
  }, []));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).TrackStarted, (0, import_react4.useCallback)((track2, participant) => {
    updateTrack(track2, track2.kind, Boolean(participant?.local));
  }, [
    updateTrack
  ]));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).ScreenTrackStarted, (0, import_react4.useCallback)((track2, participant) => {
    const trackType2 = track2.kind === "audio" ? "screenAudio" : "screenVideo";
    updateTrack(track2, trackType2, Boolean(participant?.local));
  }, [
    updateTrack
  ]));
  (0, import_react4.useEffect)(() => {
    if (!client) return;
    const tracks = client.tracks();
    const track2 = tracks?.[participantType]?.[trackType];
    if (!track2) return;
    updateTrack(track2, trackType, participantType === "local");
  }, [
    participantType,
    trackType,
    updateTrack,
    client
  ]);
  return track;
};
var $f209aa7ddb77dcb2$export$b52250cb73ff4de1 = () => {
  const botAudioRef = (0, import_react4.useRef)(null);
  const botAudioTrack = (0, $4b4b9099cdb5b776$export$9813dcd2d0c26814)("audio", "bot");
  (0, import_react4.useEffect)(() => {
    if (!botAudioRef.current || !botAudioTrack) return;
    if (botAudioRef.current.srcObject) {
      const oldTrack = botAudioRef.current.srcObject.getAudioTracks()[0];
      if (oldTrack.id === botAudioTrack.id) return;
    }
    botAudioRef.current.srcObject = new MediaStream([
      botAudioTrack
    ]);
  }, [
    botAudioTrack
  ]);
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).SpeakerUpdated, (0, import_react4.useCallback)((speaker) => {
    if (!botAudioRef.current) return;
    if (typeof botAudioRef.current.setSinkId !== "function") return;
    botAudioRef.current.setSinkId(speaker.deviceId);
  }, []));
  return (0, import_jsx_runtime.jsx)((0, import_jsx_runtime.Fragment), {
    children: (0, import_jsx_runtime.jsx)("audio", {
      ref: botAudioRef,
      autoPlay: true
    })
  });
};
$f209aa7ddb77dcb2$export$b52250cb73ff4de1.displayName = "PipecatClientAudio";
var $e76ee2f021b54325$export$3ea2601427f0430f = () => (0, import_react4.useContext)((0, $a90aa7250c094218$export$d6bdcccacef16204));
var $7cb2ce2c4cbfb401$export$dc9a029eeca8213f = ({ onCamEnabledChanged, disabled = false, children }) => {
  const { isCamEnabled, enableCam } = (0, $e76ee2f021b54325$export$3ea2601427f0430f)();
  const handleToggleCam = (0, import_react4.useCallback)(() => {
    if (disabled) return;
    const newEnabledState = !isCamEnabled;
    enableCam(newEnabledState);
    onCamEnabledChanged?.(newEnabledState);
  }, [
    disabled,
    enableCam,
    isCamEnabled,
    onCamEnabledChanged
  ]);
  return (0, import_jsx_runtime.jsx)((0, import_jsx_runtime.Fragment), {
    children: children({
      isCamEnabled,
      onClick: handleToggleCam,
      disabled
    })
  });
};
var $5905c001b0dc8d25$export$388e706586309ef0 = () => (0, import_react4.useContext)((0, $a90aa7250c094218$export$802b42df0e0d8153));
var $2984fdfc31bad375$export$bc8133b69ff660a2 = ({ onMicEnabledChanged, disabled = false, children }) => {
  const { enableMic, isMicEnabled } = (0, $5905c001b0dc8d25$export$388e706586309ef0)();
  const handleToggleMic = (0, import_react4.useCallback)(() => {
    if (disabled) return;
    const newEnabledState = !isMicEnabled;
    enableMic(newEnabledState);
    onMicEnabledChanged?.(newEnabledState);
  }, [
    disabled,
    enableMic,
    isMicEnabled,
    onMicEnabledChanged
  ]);
  return (0, import_jsx_runtime.jsx)((0, import_jsx_runtime.Fragment), {
    children: children({
      isMicEnabled,
      onClick: handleToggleMic,
      disabled
    })
  });
};
function $9098519210cf34e2$var$useMergedRef(...refs) {
  return (0, import_react4.useCallback)(
    (element) => {
      for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        if (typeof ref === "function") ref(element);
        else if (ref && typeof ref === "object") ref.current = element;
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}
var $9098519210cf34e2$export$2e2bcd8739ae039 = $9098519210cf34e2$var$useMergedRef;
var $6a65deb8615a2ad7$export$85974db6d0cc43b3 = (0, import_react4.forwardRef)(function VoiceClientVideo({ participant = "local", fit = "contain", mirror, onResize, style = {}, trackType = "video", ...props }, ref) {
  const videoTrack = (0, $4b4b9099cdb5b776$export$9813dcd2d0c26814)(trackType, participant);
  const videoEl = (0, import_react4.useRef)(null);
  const videoRef = (0, $9098519210cf34e2$export$2e2bcd8739ae039)(videoEl, ref);
  (0, import_react4.useEffect)(function setupVideoEvents() {
    const video = videoEl.current;
    if (!video) return;
    const playVideo = () => {
      const promise = video.play();
      if (promise !== void 0) promise.then(() => {
        video.controls = false;
      }).catch((error) => {
        video.controls = true;
        console.warn("Failed to play video", error);
      });
    };
    const handleCanPlay = () => {
      if (!video.paused) return;
      playVideo();
    };
    const handleEnterPIP = () => {
      video.style.transform = "scale(1)";
    };
    const handleLeavePIP = () => {
      video.style.transform = "";
      setTimeout(() => {
        if (video.paused) playVideo();
      }, 100);
    };
    const handleVisibilityChange = () => {
      if (document.visibilityState === "hidden") return;
      if (!video.paused) return;
      playVideo();
    };
    video.addEventListener("canplay", handleCanPlay);
    video.addEventListener("enterpictureinpicture", handleEnterPIP);
    video.addEventListener("leavepictureinpicture", handleLeavePIP);
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      video.removeEventListener("canplay", handleCanPlay);
      video.removeEventListener("enterpictureinpicture", handleEnterPIP);
      video.removeEventListener("leavepictureinpicture", handleLeavePIP);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);
  (0, import_react4.useEffect)(function updateSrcObject() {
    const video = videoEl.current;
    if (!video || !videoTrack) return;
    video.srcObject = new MediaStream([
      videoTrack
    ]);
    video.load();
    return () => {
      video.srcObject = null;
      video.load();
    };
  }, [
    videoTrack,
    videoTrack?.id
  ]);
  (0, import_react4.useEffect)(function reportVideoDimensions() {
    const video = videoEl.current;
    if (!onResize || !video) return;
    let frame;
    function handleResize() {
      if (frame) cancelAnimationFrame(frame);
      frame = requestAnimationFrame(() => {
        const video2 = videoEl.current;
        if (!video2 || document.hidden) return;
        const videoWidth = video2.videoWidth;
        const videoHeight = video2.videoHeight;
        if (videoWidth && videoHeight) onResize?.({
          aspectRatio: videoWidth / videoHeight,
          height: videoHeight,
          width: videoWidth
        });
      });
    }
    handleResize();
    video.addEventListener("loadedmetadata", handleResize);
    video.addEventListener("resize", handleResize);
    return () => {
      if (frame) cancelAnimationFrame(frame);
      video.removeEventListener("loadedmetadata", handleResize);
      video.removeEventListener("resize", handleResize);
    };
  }, [
    onResize
  ]);
  return (0, import_jsx_runtime.jsx)("video", {
    autoPlay: true,
    muted: true,
    playsInline: true,
    ref: videoRef,
    style: {
      objectFit: fit,
      transform: mirror ? "scale(-1, 1)" : "",
      ...style
    },
    ...props
  });
});
$6a65deb8615a2ad7$export$85974db6d0cc43b3.displayName = "PipecatClientVideo";
var $f934f1f8b10aaf19$var$availableMicsAtom = (0, atom)([]);
var $f934f1f8b10aaf19$var$availableCamsAtom = (0, atom)([]);
var $f934f1f8b10aaf19$var$availableSpeakersAtom = (0, atom)([]);
var $f934f1f8b10aaf19$var$selectedMicAtom = (0, atom)({});
var $f934f1f8b10aaf19$var$selectedCamAtom = (0, atom)({});
var $f934f1f8b10aaf19$var$selectedSpeakerAtom = (0, atom)({});
var $f934f1f8b10aaf19$export$642bc4d2d2a376f1 = () => {
  const client = (0, $034a56e7ee1b7bed$export$777fa8498be78705)();
  const availableCams = (0, useAtomValue)($f934f1f8b10aaf19$var$availableCamsAtom);
  const availableMics = (0, useAtomValue)($f934f1f8b10aaf19$var$availableMicsAtom);
  const availableSpeakers = (0, useAtomValue)($f934f1f8b10aaf19$var$availableSpeakersAtom);
  const selectedCam = (0, useAtomValue)($f934f1f8b10aaf19$var$selectedCamAtom);
  const selectedMic = (0, useAtomValue)($f934f1f8b10aaf19$var$selectedMicAtom);
  const selectedSpeaker = (0, useAtomValue)($f934f1f8b10aaf19$var$selectedSpeakerAtom);
  const initDevices = (0, useAtomCallback)((0, import_react4.useCallback)(async (_get, set) => {
    if (!client) return;
    const availableCams2 = await client.getAllCams();
    const availableMics2 = await client.getAllMics();
    const availableSpeakers2 = await client.getAllSpeakers();
    set($f934f1f8b10aaf19$var$availableCamsAtom, availableCams2);
    set($f934f1f8b10aaf19$var$availableMicsAtom, availableMics2);
    set($f934f1f8b10aaf19$var$availableSpeakersAtom, availableSpeakers2);
    set($f934f1f8b10aaf19$var$selectedCamAtom, client.selectedCam);
    set($f934f1f8b10aaf19$var$selectedMicAtom, client.selectedMic);
    set($f934f1f8b10aaf19$var$selectedSpeakerAtom, client.selectedSpeaker);
  }, [
    client
  ]));
  (0, import_react4.useEffect)(() => {
    initDevices();
  }, [
    initDevices
  ]);
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableCamsUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, cams) => {
    set($f934f1f8b10aaf19$var$availableCamsAtom, cams);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableMicsUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, mics) => {
    set($f934f1f8b10aaf19$var$availableMicsAtom, mics);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).AvailableSpeakersUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, speakers) => {
    set($f934f1f8b10aaf19$var$availableSpeakersAtom, speakers);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).CamUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, cam) => {
    set($f934f1f8b10aaf19$var$selectedCamAtom, cam);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).MicUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, mic) => {
    set($f934f1f8b10aaf19$var$selectedMicAtom, mic);
  }, [])));
  (0, $824ea64b5f757259$export$33a6ac53b8f02625)((0, $c1b4da4af54f4fa1$export$6b4624d233c61fcb).SpeakerUpdated, (0, useAtomCallback)((0, import_react4.useCallback)((_get, set, speaker) => {
    set($f934f1f8b10aaf19$var$selectedSpeakerAtom, speaker);
  }, [])));
  const updateCam = (0, import_react4.useCallback)((id) => {
    client?.updateCam(id);
  }, [
    client
  ]);
  const updateMic = (0, import_react4.useCallback)((id) => {
    client?.updateMic(id);
  }, [
    client
  ]);
  const updateSpeaker = (0, import_react4.useCallback)((id) => {
    client?.updateSpeaker(id);
  }, [
    client
  ]);
  return {
    availableCams,
    availableMics,
    availableSpeakers,
    selectedCam,
    selectedMic,
    selectedSpeaker,
    updateCam,
    updateMic,
    updateSpeaker
  };
};
var $33f3729bbe9f09df$export$30aee278309a867b = () => (0, import_react4.useContext)((0, $a90aa7250c094218$export$db79fdf85ddd6b65));
var $993a744193844a95$export$59bf27bd43679db6 = (0, import_react4.default).memo(({ backgroundColor = "transparent", barColor = "black", barCount = 5, barGap = 12, barLineCap = "round", barMaxHeight = 120, barOrigin = "center", barWidth = 30, participantType }) => {
  const canvasRef = (0, import_react4.useRef)(null);
  const track = (0, $4b4b9099cdb5b776$export$9813dcd2d0c26814)("audio", participantType);
  (0, import_react4.useEffect)(() => {
    if (!canvasRef.current) return;
    const canvasWidth = barCount * barWidth + (barCount - 1) * barGap;
    const canvasHeight = barMaxHeight;
    const canvas = canvasRef.current;
    const scaleFactor = 2;
    const resizeCanvas = () => {
      canvas.width = canvasWidth * scaleFactor;
      canvas.height = canvasHeight * scaleFactor;
      canvas.style.width = `${canvasWidth}px`;
      canvas.style.height = `${canvasHeight}px`;
      canvasCtx.lineCap = barLineCap;
      canvasCtx.scale(scaleFactor, scaleFactor);
    };
    const canvasCtx = canvas.getContext("2d");
    resizeCanvas();
    if (!track) return;
    const audioContext = new AudioContext();
    const source = audioContext.createMediaStreamSource(new MediaStream([
      track
    ]));
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;
    source.connect(analyser);
    const frequencyData = new Uint8Array(analyser.frequencyBinCount);
    canvasCtx.lineCap = barLineCap;
    const bands = Array.from({
      length: barCount
    }, (_, i) => {
      const minFreq = barCount > 20 ? 200 : 80;
      const maxFreq = 1e4;
      const melMin = 2595 * Math.log10(1 + minFreq / 700);
      const melMax = 2595 * Math.log10(1 + maxFreq / 700);
      const melStep = (melMax - melMin) / barCount;
      const melValue = melMin + i * melStep;
      const startFreq = 700 * (Math.pow(10, melValue / 2595) - 1);
      const endFreq = 700 * (Math.pow(10, (melValue + melStep) / 2595) - 1);
      return {
        startFreq,
        endFreq,
        smoothValue: 0
      };
    });
    const getFrequencyBinIndex = (frequency) => {
      const nyquist = audioContext.sampleRate / 2;
      return Math.round(frequency / nyquist * (analyser.frequencyBinCount - 1));
    };
    function drawSpectrum() {
      analyser.getByteFrequencyData(frequencyData);
      canvasCtx.clearRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);
      canvasCtx.fillStyle = backgroundColor;
      canvasCtx.fillRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);
      let isActive = false;
      const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
      const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
      const adjustedCircleRadius = barWidth / 2;
      bands.forEach((band, i) => {
        const startIndex = getFrequencyBinIndex(band.startFreq);
        const endIndex = getFrequencyBinIndex(band.endFreq);
        const bandData = frequencyData.slice(startIndex, endIndex);
        const bandValue = bandData.reduce((acc, val) => acc + val, 0) / bandData.length;
        const smoothingFactor = 0.2;
        if (bandValue < 1) band.smoothValue = Math.max(band.smoothValue - smoothingFactor * 5, 0);
        else {
          band.smoothValue = band.smoothValue + (bandValue - band.smoothValue) * smoothingFactor;
          isActive = true;
        }
        const x = startX + i * (barWidth + barGap);
        const minHeight = 0;
        const barHeight = Math.max(minHeight, Math.min(band.smoothValue / 255 * barMaxHeight, barMaxHeight));
        let yTop, yBottom;
        const canvasHeight2 = canvas.height / scaleFactor;
        switch (barOrigin) {
          case "top":
            yTop = adjustedCircleRadius;
            yBottom = Math.min(adjustedCircleRadius + barHeight, canvasHeight2 - adjustedCircleRadius);
            break;
          case "bottom":
            yBottom = canvasHeight2 - adjustedCircleRadius;
            yTop = Math.max(yBottom - barHeight, adjustedCircleRadius);
            break;
          case "center":
          default:
            yTop = Math.max(canvasHeight2 / 2 - barHeight / 2, adjustedCircleRadius);
            yBottom = Math.min(canvasHeight2 / 2 + barHeight / 2, canvasHeight2 - adjustedCircleRadius);
            break;
        }
        if (band.smoothValue > 0) {
          canvasCtx.beginPath();
          canvasCtx.moveTo(x + barWidth / 2, yTop);
          canvasCtx.lineTo(x + barWidth / 2, yBottom);
          canvasCtx.lineWidth = barWidth;
          canvasCtx.strokeStyle = barColor;
          canvasCtx.stroke();
        } else drawInactiveCircle(adjustedCircleRadius, barColor, x, yTop);
      });
      if (!isActive) drawInactiveCircles(adjustedCircleRadius, barColor);
      requestAnimationFrame(drawSpectrum);
    }
    function drawInactiveCircle(circleRadius, color, x, y) {
      switch (barLineCap) {
        case "square":
          canvasCtx.fillStyle = color;
          canvasCtx.fillRect(x + barWidth / 2 - circleRadius, y - circleRadius, circleRadius * 2, circleRadius * 2);
          break;
        case "round":
        default:
          canvasCtx.beginPath();
          canvasCtx.arc(x + barWidth / 2, y, circleRadius, 0, 2 * Math.PI);
          canvasCtx.fillStyle = color;
          canvasCtx.fill();
          canvasCtx.closePath();
          break;
      }
    }
    function drawInactiveCircles(circleRadius, color) {
      const totalBarsWidth = bands.length * barWidth + (bands.length - 1) * barGap;
      const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;
      const canvasHeight2 = canvas.height / scaleFactor;
      let y;
      switch (barOrigin) {
        case "top":
          y = circleRadius;
          break;
        case "bottom":
          y = canvasHeight2 - circleRadius;
          break;
        case "center":
        default:
          y = canvasHeight2 / 2;
          break;
      }
      bands.forEach((_, i) => {
        const x = startX + i * (barWidth + barGap);
        drawInactiveCircle(circleRadius, color, x, y);
      });
    }
    drawSpectrum();
    window.addEventListener("resize", resizeCanvas);
    return () => {
      audioContext.close();
      window.removeEventListener("resize", resizeCanvas);
    };
  }, [
    backgroundColor,
    barColor,
    barCount,
    barGap,
    barLineCap,
    barMaxHeight,
    barOrigin,
    barWidth,
    track
  ]);
  return (0, import_jsx_runtime.jsx)("canvas", {
    ref: canvasRef,
    style: {
      display: "block",
      width: "100%",
      height: "100%"
    }
  });
});
$993a744193844a95$export$59bf27bd43679db6.displayName = "VoiceVisualizer";
export {
  $f209aa7ddb77dcb2$export$b52250cb73ff4de1 as PipecatClientAudio,
  $7cb2ce2c4cbfb401$export$dc9a029eeca8213f as PipecatClientCamToggle,
  $2984fdfc31bad375$export$bc8133b69ff660a2 as PipecatClientMicToggle,
  $d2e362c5a07ee3c5$export$bb43666ced7a20d0 as PipecatClientProvider,
  $6a65deb8615a2ad7$export$85974db6d0cc43b3 as PipecatClientVideo,
  $993a744193844a95$export$59bf27bd43679db6 as VoiceVisualizer,
  $034a56e7ee1b7bed$export$777fa8498be78705 as usePipecatClient,
  $e76ee2f021b54325$export$3ea2601427f0430f as usePipecatClientCamControl,
  $f934f1f8b10aaf19$export$642bc4d2d2a376f1 as usePipecatClientMediaDevices,
  $4b4b9099cdb5b776$export$9813dcd2d0c26814 as usePipecatClientMediaTrack,
  $5905c001b0dc8d25$export$388e706586309ef0 as usePipecatClientMicControl,
  $33f3729bbe9f09df$export$30aee278309a867b as usePipecatClientTransportState,
  $824ea64b5f757259$export$33a6ac53b8f02625 as useRTVIClientEvent
};
//# sourceMappingURL=@pipecat-ai_client-react.js.map
