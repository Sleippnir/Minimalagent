{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla/internals.mjs", "../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs", "../../jotai/esm/vanilla/utils.mjs", "../../jotai/esm/react/utils.mjs", "../../@pipecat-ai/client-react/dist/client-react/src/index.ts", "../../@pipecat-ai/client-react/dist/client-react/src/PipecatClientAudio.tsx", "../../@pipecat-ai/client-react/dist/client-react/src/usePipecatClientMediaTrack.ts", "../../@pipecat-ai/client-react/dist/client-react/src/usePipecatClient.ts", "../../@pipecat-ai/client-react/dist/client-react/src/PipecatClientProvider.tsx", "../../@pipecat-ai/client-react/dist/client-react/package.json", "../../@pipecat-ai/client-react/dist/client-react/src/PipecatClientState.tsx", "../../@pipecat-ai/client-react/dist/client-react/src/useRTVIClientEvent.ts", "../../@pipecat-ai/client-react/dist/client-react/src/RTVIEventContext.ts", "../../@pipecat-ai/client-react/dist/client-react/src/PipecatClientCamToggle.tsx", "../../@pipecat-ai/client-react/dist/client-react/src/usePipecatClientCamControl.ts", "../../@pipecat-ai/client-react/dist/client-react/src/PipecatClientMicToggle.tsx", "../../@pipecat-ai/client-react/dist/client-react/src/usePipecatClientMicControl.ts", "../../@pipecat-ai/client-react/dist/client-react/src/PipecatClientVideo.tsx", "../../@pipecat-ai/client-react/dist/client-react/src/useMergedRef.ts", "../../@pipecat-ai/client-react/dist/client-react/src/usePipecatClientMediaDevices.ts", "../../@pipecat-ai/client-react/dist/client-react/src/usePipecatClientTransportState.ts", "../../@pipecat-ai/client-react/dist/client-react/src/VoiceVisualizer.tsx"],
  "sourcesContent": ["function hasInitialValue(atom) {\n  return \"init\" in atom;\n}\nfunction isActuallyWritableAtom(atom) {\n  return !!atom.write;\n}\nfunction isAtomStateInitialized(atomState) {\n  return \"v\" in atomState || \"e\" in atomState;\n}\nfunction returnAtomValue(atomState) {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n}\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nfunction isPendingPromise(value) {\n  var _a;\n  return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n}\nfunction abortPromise(promise) {\n  const promiseState = promiseStateMap.get(promise);\n  if (promiseState == null ? void 0 : promiseState[0]) {\n    promiseState[0] = false;\n    promiseState[1].forEach((fn) => fn());\n  }\n}\nfunction registerAbortHandler(promise, abortHandler) {\n  let promiseState = promiseStateMap.get(promise);\n  if (!promiseState) {\n    promiseState = [true, /* @__PURE__ */ new Set()];\n    promiseStateMap.set(promise, promiseState);\n    const settle = () => {\n      promiseState[0] = false;\n    };\n    promise.then(settle, settle);\n  }\n  promiseState[1].add(abortHandler);\n}\nfunction isPromiseLike(p) {\n  return typeof (p == null ? void 0 : p.then) === \"function\";\n}\nfunction addPendingPromiseToDependency(atom, promise, dependencyAtomState) {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    const cleanup = () => dependencyAtomState.p.delete(atom);\n    promise.then(cleanup, cleanup);\n  }\n}\nfunction getMountedOrPendingDependents(atom, atomState, mountedMap) {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    if (mountedMap.has(a)) {\n      dependents.add(a);\n    }\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n}\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => callbacks.forEach((fn) => fn());\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => callbacks.delete(fn);\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    const fns = (callbacks.has(key) ? callbacks : callbacks.set(key, /* @__PURE__ */ new Set())).get(key);\n    fns.add(fn);\n    return () => {\n      fns == null ? void 0 : fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nfunction initializeStoreHooks(storeHooks) {\n  storeHooks.r || (storeHooks.r = createStoreHookForAtoms());\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n}\nconst atomRead = (_store, atom, ...params) => atom.read(...params);\nconst atomWrite = (_store, atom, ...params) => atom.write(...params);\nconst atomOnInit = (store, atom) => {\n  var _a;\n  return (_a = atom.unstable_onInit) == null ? void 0 : _a.call(atom, store);\n};\nconst atomOnMount = (_store, atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n};\nconst ensureAtomState = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const atomStateMap = buildingBlocks[0];\n  const atomOnInit2 = buildingBlocks[9];\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n    throw new Error(\"Atom is undefined or null\");\n  }\n  let atomState = atomStateMap.get(atom);\n  if (!atomState) {\n    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n    atomStateMap.set(atom, atomState);\n    atomOnInit2 == null ? void 0 : atomOnInit2(store, atom);\n  }\n  return atomState;\n};\nconst flushCallbacks = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const mountCallbacks = buildingBlocks[4];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const errors = [];\n  const call = (fn) => {\n    try {\n      fn();\n    } catch (e) {\n      errors.push(e);\n    }\n  };\n  do {\n    if (storeHooks.f) {\n      call(storeHooks.f);\n    }\n    const callbacks = /* @__PURE__ */ new Set();\n    const add = callbacks.add.bind(callbacks);\n    changedAtoms.forEach((atom) => {\n      var _a;\n      return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n    });\n    changedAtoms.clear();\n    unmountCallbacks.forEach(add);\n    unmountCallbacks.clear();\n    mountCallbacks.forEach(add);\n    mountCallbacks.clear();\n    callbacks.forEach(call);\n    if (changedAtoms.size) {\n      recomputeInvalidatedAtoms2(store);\n    }\n  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n  if (errors.length) {\n    throw new AggregateError(errors);\n  }\n};\nconst recomputeInvalidatedAtoms = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const ensureAtomState2 = buildingBlocks[11];\n  const readAtomState2 = buildingBlocks[14];\n  const mountDependencies2 = buildingBlocks[17];\n  const topSortedReversed = [];\n  const visiting = /* @__PURE__ */ new WeakSet();\n  const visited = /* @__PURE__ */ new WeakSet();\n  const stack = Array.from(changedAtoms);\n  while (stack.length) {\n    const a = stack[stack.length - 1];\n    const aState = ensureAtomState2(store, a);\n    if (visited.has(a)) {\n      stack.pop();\n      continue;\n    }\n    if (visiting.has(a)) {\n      if (invalidatedAtoms.get(a) === aState.n) {\n        topSortedReversed.push([a, aState]);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n        throw new Error(\"[Bug] invalidated atom exists\");\n      }\n      visited.add(a);\n      stack.pop();\n      continue;\n    }\n    visiting.add(a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      if (!visiting.has(d)) {\n        stack.push(d);\n      }\n    }\n  }\n  for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n    const [a, aState] = topSortedReversed[i];\n    let hasChangedDeps = false;\n    for (const dep of aState.d.keys()) {\n      if (dep !== a && changedAtoms.has(dep)) {\n        hasChangedDeps = true;\n        break;\n      }\n    }\n    if (hasChangedDeps) {\n      readAtomState2(store, a);\n      mountDependencies2(store, a);\n    }\n    invalidatedAtoms.delete(a);\n  }\n};\nconst readAtomState = (store, atom) => {\n  var _a, _b;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomRead2 = buildingBlocks[7];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const mountDependencies2 = buildingBlocks[17];\n  const atomState = ensureAtomState2(store, atom);\n  if (isAtomStateInitialized(atomState)) {\n    if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n      return atomState;\n    }\n    if (Array.from(atomState.d).every(\n      ([a, n]) => (\n        // Recursively, read the atom state of the dependency, and\n        // check if the atom epoch number is unchanged\n        readAtomState2(store, a).n === n\n      )\n    )) {\n      return atomState;\n    }\n  }\n  atomState.d.clear();\n  let isSync = true;\n  function mountDependenciesIfAsync() {\n    if (mountedMap.has(atom)) {\n      mountDependencies2(store, atom);\n      recomputeInvalidatedAtoms2(store);\n      flushCallbacks2(store);\n    }\n  }\n  function getter(a) {\n    var _a2;\n    if (a === atom) {\n      const aState2 = ensureAtomState2(store, a);\n      if (!isAtomStateInitialized(aState2)) {\n        if (hasInitialValue(a)) {\n          setAtomStateValueOrPromise(store, a, a.init);\n        } else {\n          throw new Error(\"no atom init\");\n        }\n      }\n      return returnAtomValue(aState2);\n    }\n    const aState = readAtomState2(store, a);\n    try {\n      return returnAtomValue(aState);\n    } finally {\n      atomState.d.set(a, aState.n);\n      if (isPendingPromise(atomState.v)) {\n        addPendingPromiseToDependency(atom, atomState.v, aState);\n      }\n      (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n      if (!isSync) {\n        mountDependenciesIfAsync();\n      }\n    }\n  }\n  let controller;\n  let setSelf;\n  const options = {\n    get signal() {\n      if (!controller) {\n        controller = new AbortController();\n      }\n      return controller.signal;\n    },\n    get setSelf() {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n        console.warn(\"setSelf function cannot be used with read-only atom\");\n      }\n      if (!setSelf && isActuallyWritableAtom(atom)) {\n        setSelf = (...args) => {\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n            console.warn(\"setSelf function cannot be called in sync\");\n          }\n          if (!isSync) {\n            try {\n              return writeAtomState2(store, atom, ...args);\n            } finally {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n      }\n      return setSelf;\n    }\n  };\n  const prevEpochNumber = atomState.n;\n  try {\n    const valueOrPromise = atomRead2(store, atom, getter, options);\n    setAtomStateValueOrPromise(store, atom, valueOrPromise);\n    if (isPromiseLike(valueOrPromise)) {\n      registerAbortHandler(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n      valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n    }\n    (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom);\n    return atomState;\n  } catch (error) {\n    delete atomState.v;\n    atomState.e = error;\n    ++atomState.n;\n    return atomState;\n  } finally {\n    isSync = false;\n    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n      invalidatedAtoms.set(atom, atomState.n);\n      changedAtoms.add(atom);\n      (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom);\n    }\n  }\n};\nconst invalidateDependents = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const ensureAtomState2 = buildingBlocks[11];\n  const stack = [atom];\n  while (stack.length) {\n    const a = stack.pop();\n    const aState = ensureAtomState2(store, a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      const dState = ensureAtomState2(store, d);\n      invalidatedAtoms.set(d, dState.n);\n      stack.push(d);\n    }\n  }\n};\nconst writeAtomState = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomWrite2 = buildingBlocks[8];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountDependencies2 = buildingBlocks[17];\n  let isSync = true;\n  const getter = (a) => returnAtomValue(readAtomState2(store, a));\n  const setter = (a, ...args2) => {\n    var _a;\n    const aState = ensureAtomState2(store, a);\n    try {\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevEpochNumber = aState.n;\n        const v = args2[0];\n        setAtomStateValueOrPromise(store, a, v);\n        mountDependencies2(store, a);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n        return void 0;\n      } else {\n        return writeAtomState(store, a, ...args2);\n      }\n    } finally {\n      if (!isSync) {\n        recomputeInvalidatedAtoms2(store);\n        flushCallbacks2(store);\n      }\n    }\n  };\n  try {\n    return atomWrite2(store, atom, getter, setter, ...args);\n  } finally {\n    isSync = false;\n  }\n};\nconst mountDependencies = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const invalidateDependents2 = buildingBlocks[15];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  const mounted = mountedMap.get(atom);\n  if (mounted && !isPendingPromise(atomState.v)) {\n    for (const [a, n] of atomState.d) {\n      if (!mounted.d.has(a)) {\n        const aState = ensureAtomState2(store, a);\n        const aMounted = mountAtom2(store, a);\n        aMounted.t.add(atom);\n        mounted.d.add(a);\n        if (n !== aState.n) {\n          changedAtoms.add(a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n          invalidateDependents2(store, a);\n        }\n      }\n    }\n    for (const a of mounted.d || []) {\n      if (!atomState.d.has(a)) {\n        mounted.d.delete(a);\n        const aMounted = unmountAtom2(store, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n    }\n  }\n};\nconst mountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const mountCallbacks = buildingBlocks[4];\n  const storeHooks = buildingBlocks[6];\n  const atomOnMount2 = buildingBlocks[10];\n  const ensureAtomState2 = buildingBlocks[11];\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const readAtomState2 = buildingBlocks[14];\n  const writeAtomState2 = buildingBlocks[16];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (!mounted) {\n    readAtomState2(store, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = mountAtom(store, a);\n      aMounted.t.add(atom);\n    }\n    mounted = {\n      l: /* @__PURE__ */ new Set(),\n      d: new Set(atomState.d.keys()),\n      t: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n    if (isActuallyWritableAtom(atom)) {\n      const processOnMount = () => {\n        let isSync = true;\n        const setAtom = (...args) => {\n          try {\n            return writeAtomState2(store, atom, ...args);\n          } finally {\n            if (!isSync) {\n              recomputeInvalidatedAtoms2(store);\n              flushCallbacks2(store);\n            }\n          }\n        };\n        try {\n          const onUnmount = atomOnMount2(store, atom, setAtom);\n          if (onUnmount) {\n            mounted.u = () => {\n              isSync = true;\n              try {\n                onUnmount();\n              } finally {\n                isSync = false;\n              }\n            };\n          }\n        } finally {\n          isSync = false;\n        }\n      };\n      mountCallbacks.add(processOnMount);\n    }\n  }\n  return mounted;\n};\nconst unmountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState2 = buildingBlocks[11];\n  const unmountAtom2 = buildingBlocks[19];\n  const atomState = ensureAtomState2(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (mounted && !mounted.l.size && !Array.from(mounted.t).some((a) => {\n    var _a2;\n    return (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.d.has(atom);\n  })) {\n    if (mounted.u) {\n      unmountCallbacks.add(mounted.u);\n    }\n    mounted = void 0;\n    mountedMap.delete(atom);\n    (_a = storeHooks.u) == null ? void 0 : _a.call(storeHooks, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = unmountAtom2(store, a);\n      aMounted == null ? void 0 : aMounted.t.delete(atom);\n    }\n    return void 0;\n  }\n  return mounted;\n};\nconst setAtomStateValueOrPromise = (store, atom, valueOrPromise) => {\n  const ensureAtomState2 = getInternalBuildingBlocks(store)[11];\n  const atomState = ensureAtomState2(store, atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(\n        atom,\n        valueOrPromise,\n        ensureAtomState2(store, a)\n      );\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(prevValue);\n    }\n  }\n};\nconst storeGet = (store, atom) => {\n  const readAtomState2 = getInternalBuildingBlocks(store)[14];\n  return returnAtomValue(readAtomState2(store, atom));\n};\nconst storeSet = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const recomputeInvalidatedAtoms2 = buildingBlocks[13];\n  const writeAtomState2 = buildingBlocks[16];\n  try {\n    return writeAtomState2(store, atom, ...args);\n  } finally {\n    recomputeInvalidatedAtoms2(store);\n    flushCallbacks2(store);\n  }\n};\nconst storeSub = (store, atom, listener) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks2 = buildingBlocks[12];\n  const mountAtom2 = buildingBlocks[18];\n  const unmountAtom2 = buildingBlocks[19];\n  const mounted = mountAtom2(store, atom);\n  const listeners = mounted.l;\n  listeners.add(listener);\n  flushCallbacks2(store);\n  return () => {\n    listeners.delete(listener);\n    unmountAtom2(store, atom);\n    flushCallbacks2(store);\n  };\n};\nconst buildingBlockMap = /* @__PURE__ */ new WeakMap();\nconst getInternalBuildingBlocks = (store) => {\n  const buildingBlocks = buildingBlockMap.get(store);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !buildingBlocks) {\n    throw new Error(\n      \"Store must be created by buildStore to read its building blocks\"\n    );\n  }\n  return buildingBlocks;\n};\nfunction getBuildingBlocks(store) {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const enhanceBuildingBlocks = buildingBlocks[24];\n  if (enhanceBuildingBlocks) {\n    return enhanceBuildingBlocks(buildingBlocks);\n  }\n  return buildingBlocks;\n}\nfunction buildStore(...buildArgs) {\n  const store = {\n    get(atom) {\n      const storeGet2 = getInternalBuildingBlocks(store)[21];\n      return storeGet2(store, atom);\n    },\n    set(atom, ...args) {\n      const storeSet2 = getInternalBuildingBlocks(store)[22];\n      return storeSet2(store, atom, ...args);\n    },\n    sub(atom, listener) {\n      const storeSub2 = getInternalBuildingBlocks(store)[23];\n      return storeSub2(store, atom, listener);\n    }\n  };\n  const buildingBlocks = [\n    // store state\n    /* @__PURE__ */ new WeakMap(),\n    // atomStateMap\n    /* @__PURE__ */ new WeakMap(),\n    // mountedMap\n    /* @__PURE__ */ new WeakMap(),\n    // invalidatedAtoms\n    /* @__PURE__ */ new Set(),\n    // changedAtoms\n    /* @__PURE__ */ new Set(),\n    // mountCallbacks\n    /* @__PURE__ */ new Set(),\n    // unmountCallbacks\n    {},\n    // storeHooks\n    // atom interceptors\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount,\n    // building-block functions\n    ensureAtomState,\n    flushCallbacks,\n    recomputeInvalidatedAtoms,\n    readAtomState,\n    invalidateDependents,\n    writeAtomState,\n    mountDependencies,\n    mountAtom,\n    unmountAtom,\n    setAtomStateValueOrPromise,\n    storeGet,\n    storeSet,\n    storeSub,\n    void 0\n  ].map((fn, i) => buildArgs[i] || fn);\n  buildingBlockMap.set(store, Object.freeze(buildingBlocks));\n  return store;\n}\n\nexport { abortPromise as INTERNAL_abortPromise, addPendingPromiseToDependency as INTERNAL_addPendingPromiseToDependency, buildStore as INTERNAL_buildStoreRev2, getBuildingBlocks as INTERNAL_getBuildingBlocksRev2, getMountedOrPendingDependents as INTERNAL_getMountedOrPendingDependents, hasInitialValue as INTERNAL_hasInitialValue, initializeStoreHooks as INTERNAL_initializeStoreHooksRev2, isActuallyWritableAtom as INTERNAL_isActuallyWritableAtom, isAtomStateInitialized as INTERNAL_isAtomStateInitialized, isPendingPromise as INTERNAL_isPendingPromise, isPromiseLike as INTERNAL_isPromiseLike, promiseStateMap as INTERNAL_promiseStateMap, registerAbortHandler as INTERNAL_registerAbortHandler, returnAtomValue as INTERNAL_returnAtomValue };\n", "import { INTERNAL_buildStoreRev2 } from 'jotai/vanilla/internals';\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n  if (overiddenCreateStore) {\n    return overiddenCreateStore();\n  }\n  return INTERNAL_buildStoreRev2();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\n", "'use client';\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nimport { INTERNAL_registerAbortHandler } from 'jotai/vanilla/internals';\n\nconst StoreContext = createContext(\n  void 0\n);\nfunction useStore(options) {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n}\nfunction Provider({\n  children,\n  store\n}) {\n  const storeRef = useRef(void 0);\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise) => {\n  if (!promise.status) {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n  }\n};\nconst use = React.use || // A shim for older React versions\n((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseStatus(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const onAbort = () => {\n        try {\n          const nextValue = getValue();\n          if (isPromiseLike(nextValue)) {\n            continuablePromiseMap.set(nextValue, continuablePromise);\n            curr = nextValue;\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n            INTERNAL_registerAbortHandler(nextValue, onAbort);\n          } else {\n            resolve(nextValue);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      INTERNAL_registerAbortHandler(promise, onAbort);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (promiseStatus) {\n        try {\n          const value2 = store.get(atom);\n          if (isPromiseLike(value2)) {\n            attachPromiseStatus(\n              createContinuablePromise(value2, () => store.get(atom))\n            );\n          }\n        } catch (e) {\n        }\n      }\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay, promiseStatus]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value, () => store.get(atom));\n    if (promiseStatus) {\n      attachPromiseStatus(promise);\n    }\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n", "import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  return atom(initialValue, function(get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const listeners = /* @__PURE__ */ new Set();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    notifyListeners(\"CREATE\", param, newAtom);\n    return newAtom;\n  };\n  const notifyListeners = (type, param, atom) => {\n    for (const listener of listeners) {\n      listener({ type, param, atom });\n    }\n  };\n  createAtom.unstable_listen = (callback) => {\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n    };\n  };\n  createAtom.getParams = () => atoms.keys();\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      if (!atoms.has(param)) return;\n      const [atom] = atoms.get(param);\n      atoms.delete(param);\n      notifyListeners(\"REMOVE\", param, atom);\n    } else {\n      for (const [key, [atom]] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          notifyListeners(\"REMOVE\", key, atom);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, [atom, createdAt]] of atoms) {\n      if (shouldRemove(createdAt, key)) {\n        atoms.delete(key);\n        notifyListeners(\"REMOVE\", key, atom);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (value) => {\n  if (typeof value !== \"object\" || value === null) {\n    return value;\n  }\n  Object.freeze(value);\n  const propNames = Object.getOwnPropertyNames(value);\n  for (const name of propNames) {\n    deepFreeze(value[name]);\n  }\n  return value;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function(get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function(get, set, ...args) {\n      return origWrite.call(\n        this,\n        get,\n        (...setArgs) => {\n          if (setArgs[0] === anAtom) {\n            setArgs[1] = deepFreeze(setArgs[1]);\n          }\n          return set(...setArgs);\n        },\n        ...args\n      );\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\"\n    );\n  }\n  return ((...args) => freezeAtom(createAtom(...args)));\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      const newValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(overwrittenAtom, newValue === RESET ? EMPTY : newValue);\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike$3 = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike$3(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike$3(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {\n  }\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (isPromiseLike$3(nextValue)) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike$2 = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const unsubscribe = () => {\n      if (subscription) {\n        subscription.unsubscribe();\n        subscription = void 0;\n      }\n    };\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(unsubscribe, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (options == null ? void 0 : options.unstable_timeout) {\n          timer = setTimeout(unsubscribe, options.unstable_timeout);\n        } else {\n          unsubscribe();\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (isPromiseLike$2(result)) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromiseLike$1 = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!isPromiseLike$1(value)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached1 = loadableCache.get(promise);\n        if (cached1) {\n          return cached1;\n        }\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n            setSelf();\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n            setSelf();\n          }\n        );\n        const cached2 = loadableCache.get(promise);\n        if (cached2) {\n          return cached2;\n        }\n        loadableCache.set(promise, LOADING);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === \"function\";\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!isPromiseLike(promise)) {\n            return { v: promise };\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => {\n                promiseResultCache.set(promise, v);\n                setSelf();\n              },\n              (e) => {\n                promiseErrorCache.set(promise, e);\n                setSelf();\n              }\n            );\n          }\n          if (promiseErrorCache.has(promise)) {\n            throw promiseErrorCache.get(promise);\n          }\n          if (promiseResultCache.has(promise)) {\n            return {\n              p: promise,\n              v: promiseResultCache.get(promise)\n            };\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = atom(0);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return atom(\n    (get, options) => {\n      get(refreshAtom);\n      return read(get, options);\n    },\n    (get, set, ...args) => {\n      if (args.length === 0) {\n        set(refreshAtom, (c) => c + 1);\n      } else if (write) {\n        return write(get, set, ...args);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        throw new Error(\"refresh must be called without arguments\");\n      }\n    }\n  );\n}\n\nfunction atomWithLazy(makeInitial) {\n  const a = atom(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithLazy, atomWithObservable, atomWithReducer, atomWithRefresh, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };\n", "'use client';\nimport { useCallback, useMemo } from 'react';\nimport { useSetAtom, useAtom, useStore } from 'jotai/react';\nimport { RESET } from 'jotai/vanilla/utils';\nimport { atom } from 'jotai/vanilla';\n\nfunction useResetAtom(anAtom, options) {\n  const setAtom = useSetAtom(anAtom, options);\n  const resetAtom = useCallback(() => setAtom(RESET), [setAtom]);\n  return resetAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, options) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] useReducerAtom is deprecated and will be removed in the future. Please create your own version using the recipe. https://github.com/pmndrs/jotai/pull/2467\"\n    );\n  }\n  const [state, setState] = useAtom(anAtom, options);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction useAtomCallback(callback, options) {\n  const anAtom = useMemo(\n    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),\n    [callback]\n  );\n  return useSetAtom(anAtom, options);\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, options) {\n  const store = useStore(options);\n  const hydratedSet = getHydratedSet(store);\n  for (const [atom, ...args] of values) {\n    if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {\n      hydratedSet.add(atom);\n      store.set(atom, ...args);\n    }\n  }\n}\nconst getHydratedSet = (store) => {\n  let hydratedSet = hydratedMap.get(store);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(store, hydratedSet);\n  }\n  return hydratedSet;\n};\n\nexport { useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom };\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { PipecatClientAudio } from \"./PipecatClientAudio\";\nimport { PipecatClientCamToggle } from \"./PipecatClientCamToggle\";\nimport { PipecatClientMicToggle } from \"./PipecatClientMicToggle\";\nimport { PipecatClientProvider } from \"./PipecatClientProvider\";\nimport { PipecatClientVideo } from \"./PipecatClientVideo\";\nimport { usePipecatClient } from \"./usePipecatClient\";\nimport { usePipecatClientCamControl } from \"./usePipecatClientCamControl\";\nimport { usePipecatClientMediaDevices } from \"./usePipecatClientMediaDevices\";\nimport { usePipecatClientMediaTrack } from \"./usePipecatClientMediaTrack\";\nimport { usePipecatClientMicControl } from \"./usePipecatClientMicControl\";\nimport { usePipecatClientTransportState } from \"./usePipecatClientTransportState\";\nimport { useRTVIClientEvent } from \"./useRTVIClientEvent\";\nimport { VoiceVisualizer } from \"./VoiceVisualizer\";\n\nexport {\n  PipecatClientAudio,\n  PipecatClientCamToggle,\n  PipecatClientMicToggle,\n  PipecatClientProvider,\n  PipecatClientVideo,\n  usePipecatClient,\n  usePipecatClientCamControl,\n  usePipecatClientMediaDevices,\n  usePipecatClientMediaTrack,\n  usePipecatClientMicControl,\n  usePipecatClientTransportState,\n  useRTVIClientEvent,\n  VoiceVisualizer,\n};\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIEvent } from \"@pipecat-ai/client-js\";\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport { usePipecatClientMediaTrack } from \"./usePipecatClientMediaTrack\";\nimport { useRTVIClientEvent } from \"./useRTVIClientEvent\";\n\nexport const PipecatClientAudio = () => {\n  const botAudioRef = useRef<HTMLAudioElement>(null);\n  const botAudioTrack = usePipecatClientMediaTrack(\"audio\", \"bot\");\n\n  useEffect(() => {\n    if (!botAudioRef.current || !botAudioTrack) return;\n    if (botAudioRef.current.srcObject) {\n      const oldTrack = (\n        botAudioRef.current.srcObject as MediaStream\n      ).getAudioTracks()[0];\n      if (oldTrack.id === botAudioTrack.id) return;\n    }\n    botAudioRef.current.srcObject = new MediaStream([botAudioTrack]);\n  }, [botAudioTrack]);\n\n  useRTVIClientEvent(\n    RTVIEvent.SpeakerUpdated,\n    useCallback((speaker: MediaDeviceInfo) => {\n      if (!botAudioRef.current) return;\n      if (typeof botAudioRef.current.setSinkId !== \"function\") return;\n      botAudioRef.current.setSinkId(speaker.deviceId);\n    }, [])\n  );\n\n  return (\n    <>\n      <audio ref={botAudioRef} autoPlay />\n    </>\n  );\n};\nPipecatClientAudio.displayName = \"PipecatClientAudio\";\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { Participant, RTVIEvent, Tracks } from \"@pipecat-ai/client-js\";\nimport { atom, useAtomValue } from \"jotai\";\nimport { atomFamily, useAtomCallback } from \"jotai/utils\";\nimport { PrimitiveAtom } from \"jotai/vanilla\";\nimport { useCallback, useEffect } from \"react\";\n\nimport { usePipecatClient } from \"./usePipecatClient\";\nimport { useRTVIClientEvent } from \"./useRTVIClientEvent\";\n\ntype ParticipantType = keyof Tracks;\ntype TrackType = keyof Tracks[\"local\"];\n\nconst localAudioTrackAtom = atom<MediaStreamTrack | null>(null);\nconst localVideoTrackAtom = atom<MediaStreamTrack | null>(null);\nconst localScreenAudioTrackAtom = atom<MediaStreamTrack | null>(null);\nconst localScreenVideoTrackAtom = atom<MediaStreamTrack | null>(null);\nconst botAudioTrackAtom = atom<MediaStreamTrack | null>(null);\nconst botVideoTrackAtom = atom<MediaStreamTrack | null>(null);\n\nconst trackAtom = atomFamily<\n  { local: boolean; trackType: TrackType },\n  PrimitiveAtom<MediaStreamTrack | null>\n>(({ local, trackType }) => {\n  if (local) {\n    switch (trackType) {\n      case \"audio\":\n        return localAudioTrackAtom;\n      case \"screenAudio\":\n        return localScreenAudioTrackAtom;\n      case \"screenVideo\":\n        return localScreenVideoTrackAtom;\n      case \"video\":\n        return localVideoTrackAtom;\n    }\n  }\n  return trackType === \"audio\" ? botAudioTrackAtom : botVideoTrackAtom;\n});\n\nexport const usePipecatClientMediaTrack = (\n  trackType: TrackType,\n  participantType: ParticipantType\n) => {\n  const client = usePipecatClient();\n  const track = useAtomValue(\n    trackAtom({ local: participantType === \"local\", trackType })\n  );\n\n  const updateTrack = useAtomCallback(\n    useCallback(\n      (\n        get,\n        set,\n        track: MediaStreamTrack,\n        trackType: TrackType,\n        local: boolean\n      ) => {\n        const atom = trackAtom({\n          local,\n          trackType,\n        });\n        const oldTrack = get(atom);\n        if (oldTrack?.id === track.id) return;\n        set(atom, track);\n      },\n      []\n    )\n  );\n\n  useRTVIClientEvent(\n    RTVIEvent.TrackStarted,\n    useCallback(\n      (track: MediaStreamTrack, participant?: Participant) => {\n        updateTrack(\n          track,\n          track.kind as TrackType,\n          Boolean(participant?.local)\n        );\n      },\n      [updateTrack]\n    )\n  );\n\n  useRTVIClientEvent(\n    RTVIEvent.ScreenTrackStarted,\n    useCallback(\n      (track: MediaStreamTrack, participant?: Participant) => {\n        const trackType =\n          track.kind === \"audio\" ? \"screenAudio\" : \"screenVideo\";\n        updateTrack(track, trackType, Boolean(participant?.local));\n      },\n      [updateTrack]\n    )\n  );\n\n  useEffect(() => {\n    if (!client) return;\n    const tracks = client.tracks();\n    const track = tracks?.[participantType]?.[trackType];\n    if (!track) return;\n    updateTrack(track, trackType, participantType === \"local\");\n  }, [participantType, trackType, updateTrack, client]);\n\n  return track;\n};\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { useContext } from \"react\";\n\nimport { PipecatClientContext } from \"./PipecatClientProvider\";\n\nexport const usePipecatClient = () => {\n  const { client } = useContext(PipecatClientContext);\n  return client;\n};\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport {\n  PipecatClient,\n  RTVIEvent,\n  RTVIEventHandler,\n  setAboutClient,\n} from \"@pipecat-ai/client-js\";\nimport { createStore } from \"jotai\";\nimport { Provider as JotaiProvider } from \"jotai/react\";\nimport React, { createContext, useCallback, useEffect, useRef } from \"react\";\n\nimport {\n  name as packageName,\n  version as packageVersion,\n} from \"../package.json\";\nimport { PipecatClientStateProvider } from \"./PipecatClientState\";\nimport { RTVIEventContext } from \"./RTVIEventContext\";\n\nexport interface Props {\n  client: PipecatClient;\n  jotaiStore?: React.ComponentProps<typeof JotaiProvider>[\"store\"];\n}\n\nconst defaultStore = createStore();\n\nexport const PipecatClientContext = createContext<{ client?: PipecatClient }>(\n  {}\n);\n\ntype EventHandlersMap = {\n  [E in RTVIEvent]?: Set<RTVIEventHandler<E>>;\n};\n\nexport const PipecatClientProvider: React.FC<\n  React.PropsWithChildren<Props>\n> = ({ children, client, jotaiStore = defaultStore }) => {\n  useEffect(() => {\n    setAboutClient({\n      library: packageName,\n      library_version: packageVersion,\n    });\n  }, []);\n\n  const eventHandlersMap = useRef<EventHandlersMap>({});\n\n  useEffect(() => {\n    if (!client) return;\n\n    const allEvents = Object.values(RTVIEvent).filter((value) =>\n      isNaN(Number(value))\n    ) as RTVIEvent[];\n\n    const allHandlers: Partial<\n      Record<\n        RTVIEvent,\n        (\n          ...args: Parameters<Exclude<RTVIEventHandler<RTVIEvent>, undefined>>\n        ) => void\n      >\n    > = {};\n\n    allEvents.forEach((event) => {\n      type E = typeof event;\n      type Handler = Exclude<RTVIEventHandler<E>, undefined>; // Remove undefined\n      type Payload = Parameters<Handler>; // Will always be a tuple\n\n      const handler = (...payload: Payload) => {\n        const handlers = eventHandlersMap.current[event] as\n          | Set<Handler>\n          | undefined;\n        if (!handlers) return;\n        handlers.forEach((h) => {\n          (\n            h as (\n              ...args: Parameters<Exclude<RTVIEventHandler<E>, undefined>>\n            ) => void\n          )(...payload);\n        });\n      };\n\n      allHandlers[event] = handler;\n\n      client.on(event, handler);\n    });\n\n    return () => {\n      allEvents.forEach((event) => {\n        client.off(event, allHandlers[event]);\n      });\n    };\n  }, [client]);\n\n  const on = useCallback(\n    <E extends RTVIEvent>(event: E, handler: RTVIEventHandler<E>) => {\n      if (!eventHandlersMap.current[event]) {\n        eventHandlersMap.current[event] = new Set();\n      }\n      eventHandlersMap.current[event]!.add(handler);\n    },\n    []\n  );\n\n  const off = useCallback(\n    <E extends RTVIEvent>(event: E, handler: RTVIEventHandler<E>) => {\n      eventHandlersMap.current[event]?.delete(handler);\n    },\n    []\n  );\n\n  return (\n    <JotaiProvider store={jotaiStore}>\n      <PipecatClientContext.Provider value={{ client }}>\n        <RTVIEventContext.Provider value={{ on, off }}>\n          <PipecatClientStateProvider>{children}</PipecatClientStateProvider>\n        </RTVIEventContext.Provider>\n      </PipecatClientContext.Provider>\n    </JotaiProvider>\n  );\n};\nPipecatClientProvider.displayName = \"PipecatClientProvider\";\n", "{\n  \"name\": \"@pipecat-ai/client-react\",\n  \"version\": \"1.0.1\",\n  \"license\": \"BSD-2-Clause\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.module.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"source\": \"src/index.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/pipecat-ai/pipecat-client-web.git\"\n  },\n  \"files\": [\n    \"dist\",\n    \"package.json\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"parcel build --no-cache\",\n    \"dev\": \"parcel watch\",\n    \"lint\": \"eslint . --report-unused-disable-directives --max-warnings 0 --ignore-pattern 'dist/'\"\n  },\n  \"devDependencies\": {\n    \"@pipecat-ai/client-js\": \"*\",\n    \"@types/react\": \"^18.3.3\",\n    \"@types/react-dom\": \"^18.3.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.32.0\",\n    \"eslint\": \"^9.11.1\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"eslint-plugin-react-hooks\": \"^5.2.0\",\n    \"eslint-plugin-simple-import-sort\": \"^12.1.1\",\n    \"parcel\": \"^2.12.0\",\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"typescript\": \"^5.2.2\"\n  },\n  \"peerDependencies\": {\n    \"@pipecat-ai/client-js\": \"*\",\n    \"react\": \">=18\",\n    \"react-dom\": \">=18\"\n  },\n  \"dependencies\": {\n    \"jotai\": \"^2.9.0\"\n  }\n}\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIEvent, TransportState } from \"@pipecat-ai/client-js\";\nimport React, { createContext, useCallback, useState } from \"react\";\n\nimport { usePipecatClient } from \"./usePipecatClient\";\nimport { useRTVIClientEvent } from \"./useRTVIClientEvent\";\n\nexport const PipecatClientCamStateContext = createContext<{\n  enableCam: (enabled: boolean) => void;\n  isCamEnabled: boolean;\n}>({\n  enableCam: () => {\n    throw new Error(\n      \"PipecatClientCamStateContext: enableCam() called outside of provider\"\n    );\n  },\n  isCamEnabled: false,\n});\nexport const PipecatClientMicStateContext = createContext<{\n  enableMic: (enabled: boolean) => void;\n  isMicEnabled: boolean;\n}>({\n  enableMic: () => {\n    throw new Error(\n      \"PipecatClientMicStateContext: enableMic() called outside of provider\"\n    );\n  },\n  isMicEnabled: false,\n});\nexport const PipecatClientTransportStateContext =\n  createContext<TransportState>(\"disconnected\");\n\nexport const PipecatClientStateProvider: React.FC<React.PropsWithChildren> = ({\n  children,\n}) => {\n  const client = usePipecatClient();\n  const [isCamEnabled, setIsCamEnabled] = useState(false);\n  const [isMicEnabled, setIsMicEnabled] = useState(false);\n  const [transportState, setTransportState] =\n    useState<TransportState>(\"disconnected\");\n\n  useRTVIClientEvent(RTVIEvent.TransportStateChanged, (state) => {\n    setTransportState(state);\n    if (state === \"initialized\" && client) {\n      setIsCamEnabled(client.isCamEnabled ?? false);\n      setIsMicEnabled(client.isMicEnabled ?? false);\n    }\n  });\n\n  const enableCam = useCallback(\n    (enabled: boolean) => {\n      setIsCamEnabled(enabled);\n      client?.enableCam?.(enabled);\n    },\n    [client]\n  );\n\n  const enableMic = useCallback(\n    (enabled: boolean) => {\n      setIsMicEnabled(enabled);\n      client?.enableMic?.(enabled);\n    },\n    [client]\n  );\n\n  return (\n    <PipecatClientTransportStateContext.Provider value={transportState}>\n      <PipecatClientCamStateContext.Provider\n        value={{ enableCam, isCamEnabled }}\n      >\n        <PipecatClientMicStateContext.Provider\n          value={{ enableMic, isMicEnabled }}\n        >\n          {children}\n        </PipecatClientMicStateContext.Provider>\n      </PipecatClientCamStateContext.Provider>\n    </PipecatClientTransportStateContext.Provider>\n  );\n};\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIEvent, RTVIEventHandler } from \"@pipecat-ai/client-js\";\nimport { useContext, useEffect } from \"react\";\n\nimport { RTVIEventContext } from \"./RTVIEventContext\";\n\nexport const useRTVIClientEvent = <E extends RTVIEvent>(\n  event: E,\n  handler: RTVIEventHandler<E>\n) => {\n  const { on, off } = useContext(RTVIEventContext);\n\n  useEffect(() => {\n    on(event, handler);\n    return () => {\n      off(event, handler);\n    };\n  }, [event, handler, on, off]);\n};\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\nimport { RTVIEvent, RTVIEventHandler } from \"@pipecat-ai/client-js\";\nimport { createContext } from \"react\";\n\nexport const RTVIEventContext = createContext<{\n  on: <E extends RTVIEvent>(event: E, handler: RTVIEventHandler<E>) => void;\n  off: <E extends RTVIEvent>(event: E, handler: RTVIEventHandler<E>) => void;\n}>({\n  on: () => {},\n  off: () => {},\n});\n", "import React, { useCallback } from \"react\";\n\nimport { usePipecatClientCamControl } from \"./usePipecatClientCamControl\";\n\nexport interface PipecatClientCamToggleProps {\n  /**\n   * Callback fired when camera state changes\n   */\n  onCamEnabledChanged?: (enabled: boolean) => void;\n\n  /**\n   * Optional prop to disable the cam toggle.\n   * When disabled, changes are not applied to the client.\n   * @default false\n   */\n  disabled?: boolean;\n\n  /**\n   * Render prop that provides state and handlers to the children\n   */\n  children: (props: {\n    disabled?: boolean;\n    isCamEnabled: boolean;\n    onClick: () => void;\n  }) => React.ReactNode;\n}\n\n/**\n * Headless component for controlling camera state\n */\nexport const PipecatClientCamToggle: React.FC<PipecatClientCamToggleProps> = ({\n  onCamEnabledChanged,\n  disabled = false,\n  children,\n}) => {\n  const { isCamEnabled, enableCam } = usePipecatClientCamControl();\n\n  const handleToggleCam = useCallback(() => {\n    if (disabled) return;\n\n    const newEnabledState = !isCamEnabled;\n    enableCam(newEnabledState);\n    onCamEnabledChanged?.(newEnabledState);\n  }, [disabled, enableCam, isCamEnabled, onCamEnabledChanged]);\n\n  return (\n    <>\n      {children({\n        isCamEnabled,\n        onClick: handleToggleCam,\n        disabled,\n      })}\n    </>\n  );\n};\n\nexport default PipecatClientCamToggle;\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\nimport { useContext } from \"react\";\n\nimport { PipecatClientCamStateContext } from \"./PipecatClientState\";\n\n/**\n * Hook to control camera state\n */\nexport const usePipecatClientCamControl = () =>\n  useContext(PipecatClientCamStateContext);\n", "import React, { useCallback } from \"react\";\n\nimport { usePipecatClientMicControl } from \"./usePipecatClientMicControl\";\n\nexport interface PipecatClientMicToggleProps {\n  /**\n   * Callback fired when microphone state changes\n   */\n  onMicEnabledChanged?: (enabled: boolean) => void;\n\n  /**\n   * Optional prop to disable the mic toggle.\n   * When disabled, changes are not applied to the client.\n   * @default false\n   */\n  disabled?: boolean;\n\n  /**\n   * Render prop that provides state and handlers to the children\n   */\n  children: (props: {\n    disabled?: boolean;\n    isMicEnabled: boolean;\n    onClick: () => void;\n  }) => React.ReactNode;\n}\n\n/**\n * Headless component for controlling microphone state\n */\nexport const PipecatClientMicToggle: React.FC<PipecatClientMicToggleProps> = ({\n  onMicEnabledChanged,\n  disabled = false,\n  children,\n}) => {\n  const { enableMic, isMicEnabled } = usePipecatClientMicControl();\n\n  const handleToggleMic = useCallback(() => {\n    if (disabled) return;\n\n    const newEnabledState = !isMicEnabled;\n    enableMic(newEnabledState);\n    onMicEnabledChanged?.(newEnabledState);\n  }, [disabled, enableMic, isMicEnabled, onMicEnabledChanged]);\n\n  return (\n    <>\n      {children({\n        isMicEnabled,\n        onClick: handleToggleMic,\n        disabled,\n      })}\n    </>\n  );\n};\n\nexport default PipecatClientMicToggle;\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { useContext } from \"react\";\n\nimport { PipecatClientMicStateContext } from \"./PipecatClientState\";\n\n/**\n * Hook to control microphone state\n */\nexport const usePipecatClientMicControl = () =>\n  useContext(PipecatClientMicStateContext);\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport React, { forwardRef, useEffect, useRef } from \"react\";\n\nimport useMergedRef from \"./useMergedRef\";\nimport { usePipecatClientMediaTrack } from \"./usePipecatClientMediaTrack\";\n\ninterface PipecatClientVideoInterface {\n  aspectRatio: number;\n  height: number;\n  width: number;\n}\n\nexport interface Props\n  extends Omit<React.VideoHTMLAttributes<HTMLVideoElement>, \"onResize\"> {\n  participant: \"local\" | \"bot\";\n\n  /**\n   * Defines the video track type to display. Default: 'video'.\n   */\n  trackType?: \"screenVideo\" | \"video\";\n\n  /**\n   * Defines whether the video should be fully contained or cover the box. Default: 'contain'.\n   */\n  fit?: \"contain\" | \"cover\";\n  /**\n   * Forces the video to be mirrored, if set.\n   */\n  mirror?: boolean;\n\n  /**\n   * Optional callback, which is triggered whenever the video's rendered width or height changes.\n   * Returns the video's native width, height and aspectRatio.\n   */\n  onResize?(dimensions: PipecatClientVideoInterface): void;\n}\n\nexport const PipecatClientVideo = forwardRef<HTMLVideoElement, Props>(\n  function VoiceClientVideo(\n    {\n      participant = \"local\",\n      fit = \"contain\",\n      mirror,\n      onResize,\n      style = {},\n      trackType = \"video\",\n      ...props\n    },\n    ref\n  ) {\n    const videoTrack: MediaStreamTrack | null = usePipecatClientMediaTrack(\n      trackType,\n      participant\n    );\n\n    const videoEl = useRef<HTMLVideoElement>(null);\n    const videoRef = useMergedRef<HTMLVideoElement>(videoEl, ref);\n\n    /**\n     * Handle canplay & picture-in-picture events.\n     */\n    useEffect(function setupVideoEvents() {\n      const video = videoEl.current;\n      if (!video) return;\n\n      const playVideo = () => {\n        const promise = video.play();\n        if (promise !== undefined) {\n          promise\n            .then(() => {\n              // All good, playback started.\n              video.controls = false;\n            })\n            .catch((error) => {\n              // Auto-play was prevented. Show video controls, so user can play video manually.\n              video.controls = true;\n              console.warn(\"Failed to play video\", error);\n            });\n        }\n      };\n\n      const handleCanPlay = () => {\n        if (!video.paused) return;\n        playVideo();\n      };\n      const handleEnterPIP = () => {\n        video.style.transform = \"scale(1)\";\n      };\n      const handleLeavePIP = () => {\n        video.style.transform = \"\";\n        setTimeout(() => {\n          if (video.paused) playVideo();\n        }, 100);\n      };\n      const handleVisibilityChange = () => {\n        if (document.visibilityState === \"hidden\") return;\n        if (!video.paused) return;\n        playVideo();\n      };\n      video.addEventListener(\"canplay\", handleCanPlay);\n      video.addEventListener(\"enterpictureinpicture\", handleEnterPIP);\n      video.addEventListener(\"leavepictureinpicture\", handleLeavePIP);\n\n      // Videos can be paused if media was played in another app on iOS.\n      document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n      return () => {\n        video.removeEventListener(\"canplay\", handleCanPlay);\n        video.removeEventListener(\"enterpictureinpicture\", handleEnterPIP);\n        video.removeEventListener(\"leavepictureinpicture\", handleLeavePIP);\n        document.removeEventListener(\n          \"visibilitychange\",\n          handleVisibilityChange\n        );\n      };\n    }, []);\n\n    /**\n     * Update srcObject.\n     */\n    useEffect(\n      function updateSrcObject() {\n        const video = videoEl.current;\n        if (!video || !videoTrack) return;\n        video.srcObject = new MediaStream([videoTrack]);\n        video.load();\n        return () => {\n          // clean up when unmounted\n          video.srcObject = null;\n          video.load();\n        };\n      },\n      [videoTrack, videoTrack?.id]\n    );\n\n    /**\n     * Add optional event listener for resize event so the parent component\n     * can know the video's native aspect ratio.\n     */\n    useEffect(\n      function reportVideoDimensions() {\n        const video = videoEl.current;\n        if (!onResize || !video) return;\n\n        let frame: ReturnType<typeof requestAnimationFrame>;\n        function handleResize() {\n          if (frame) cancelAnimationFrame(frame);\n          frame = requestAnimationFrame(() => {\n            const video = videoEl.current;\n            if (!video || document.hidden) return;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            if (videoWidth && videoHeight) {\n              onResize?.({\n                aspectRatio: videoWidth / videoHeight,\n                height: videoHeight,\n                width: videoWidth,\n              });\n            }\n          });\n        }\n\n        handleResize();\n        video.addEventListener(\"loadedmetadata\", handleResize);\n        video.addEventListener(\"resize\", handleResize);\n\n        return () => {\n          if (frame) cancelAnimationFrame(frame);\n          video.removeEventListener(\"loadedmetadata\", handleResize);\n          video.removeEventListener(\"resize\", handleResize);\n        };\n      },\n      [onResize]\n    );\n\n    return (\n      <video\n        autoPlay\n        muted\n        playsInline\n        ref={videoRef}\n        style={{\n          objectFit: fit,\n          transform: mirror ? \"scale(-1, 1)\" : \"\",\n          ...style,\n        }}\n        {...props}\n      />\n    );\n  }\n);\nPipecatClientVideo.displayName = \"PipecatClientVideo\";\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n * This file contains code derived from:\n * https://github.com/jaredLunde/react-hook/blob/master/packages/merged-ref/src/index.tsx\n * Original author: Jared Lunde (https://github.com/jaredLunde)\n * Original license: MIT (https://github.com/jaredLunde/react-hook/blob/master/LICENSE)\n */\n\nimport React, { useCallback } from \"react\";\n\nfunction useMergedRef<T>(...refs: React.Ref<T>[]): React.RefCallback<T> {\n  return useCallback(\n    (element: T) => {\n      for (let i = 0; i < refs.length; i++) {\n        const ref = refs[i];\n        if (typeof ref === \"function\") ref(element);\n        else if (ref && typeof ref === \"object\")\n          (ref as React.MutableRefObject<T>).current = element;\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\n\nexport default useMergedRef;\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\nimport { RTVIEvent } from \"@pipecat-ai/client-js\";\nimport { atom, useAtomValue } from \"jotai\";\nimport { useAtomCallback } from \"jotai/utils\";\nimport { useCallback, useEffect } from \"react\";\n\nimport { usePipecatClient } from \"./usePipecatClient\";\nimport { useRTVIClientEvent } from \"./useRTVIClientEvent\";\n\ntype OptionalMediaDeviceInfo = MediaDeviceInfo | Record<string, never>;\n\nconst availableMicsAtom = atom<MediaDeviceInfo[]>([]);\nconst availableCamsAtom = atom<MediaDeviceInfo[]>([]);\nconst availableSpeakersAtom = atom<MediaDeviceInfo[]>([]);\nconst selectedMicAtom = atom<OptionalMediaDeviceInfo>({});\nconst selectedCamAtom = atom<OptionalMediaDeviceInfo>({});\nconst selectedSpeakerAtom = atom<OptionalMediaDeviceInfo>({});\n\nexport const usePipecatClientMediaDevices = () => {\n  const client = usePipecatClient();\n\n  const availableCams = useAtomValue(availableCamsAtom);\n  const availableMics = useAtomValue(availableMicsAtom);\n  const availableSpeakers = useAtomValue(availableSpeakersAtom);\n  const selectedCam = useAtomValue(selectedCamAtom);\n  const selectedMic = useAtomValue(selectedMicAtom);\n  const selectedSpeaker = useAtomValue(selectedSpeakerAtom);\n\n  const initDevices = useAtomCallback(\n    useCallback(\n      async (_get, set) => {\n        if (!client) return;\n\n        const availableCams = await client.getAllCams();\n        const availableMics = await client.getAllMics();\n        const availableSpeakers = await client.getAllSpeakers();\n\n        set(availableCamsAtom, availableCams);\n        set(availableMicsAtom, availableMics);\n        set(availableSpeakersAtom, availableSpeakers);\n\n        set(selectedCamAtom, client.selectedCam);\n        set(selectedMicAtom, client.selectedMic);\n        set(selectedSpeakerAtom, client.selectedSpeaker);\n      },\n      [client]\n    )\n  );\n\n  useEffect(() => {\n    initDevices();\n  }, [initDevices]);\n\n  useRTVIClientEvent(\n    RTVIEvent.AvailableCamsUpdated,\n    useAtomCallback(\n      useCallback((_get, set, cams) => {\n        set(availableCamsAtom, cams);\n      }, [])\n    )\n  );\n  useRTVIClientEvent(\n    RTVIEvent.AvailableMicsUpdated,\n    useAtomCallback(\n      useCallback((_get, set, mics) => {\n        set(availableMicsAtom, mics);\n      }, [])\n    )\n  );\n  useRTVIClientEvent(\n    RTVIEvent.AvailableSpeakersUpdated,\n    useAtomCallback(\n      useCallback((_get, set, speakers) => {\n        set(availableSpeakersAtom, speakers);\n      }, [])\n    )\n  );\n  useRTVIClientEvent(\n    RTVIEvent.CamUpdated,\n    useAtomCallback(\n      useCallback((_get, set, cam) => {\n        set(selectedCamAtom, cam);\n      }, [])\n    )\n  );\n  useRTVIClientEvent(\n    RTVIEvent.MicUpdated,\n    useAtomCallback(\n      useCallback((_get, set, mic) => {\n        set(selectedMicAtom, mic);\n      }, [])\n    )\n  );\n  useRTVIClientEvent(\n    RTVIEvent.SpeakerUpdated,\n    useAtomCallback(\n      useCallback((_get, set, speaker) => {\n        set(selectedSpeakerAtom, speaker);\n      }, [])\n    )\n  );\n\n  const updateCam = useCallback(\n    (id: string) => {\n      client?.updateCam(id);\n    },\n    [client]\n  );\n  const updateMic = useCallback(\n    (id: string) => {\n      client?.updateMic(id);\n    },\n    [client]\n  );\n  const updateSpeaker = useCallback(\n    (id: string) => {\n      client?.updateSpeaker(id);\n    },\n    [client]\n  );\n\n  return {\n    availableCams,\n    availableMics,\n    availableSpeakers,\n    selectedCam,\n    selectedMic,\n    selectedSpeaker,\n    updateCam,\n    updateMic,\n    updateSpeaker,\n  };\n};\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { useContext } from \"react\";\n\nimport { PipecatClientTransportStateContext } from \"./PipecatClientState\";\n\nexport const usePipecatClientTransportState = () =>\n  useContext(PipecatClientTransportStateContext);\n", "/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport React, { useEffect, useRef } from \"react\";\n\nimport { usePipecatClientMediaTrack } from \"./usePipecatClientMediaTrack\";\n\ntype ParticipantType = Parameters<typeof usePipecatClientMediaTrack>[1];\n\ninterface Props {\n  backgroundColor?: string;\n  barColor?: string;\n  barCount?: number;\n  barGap?: number;\n  barLineCap?: \"round\" | \"square\";\n  barMaxHeight?: number;\n  barOrigin?: \"top\" | \"bottom\" | \"center\";\n  barWidth?: number;\n  participantType: ParticipantType;\n}\n\nexport const VoiceVisualizer: React.FC<Props> = React.memo(\n  ({\n    backgroundColor = \"transparent\",\n    barColor = \"black\",\n    barCount = 5,\n    barGap = 12,\n    barLineCap = \"round\",\n    barMaxHeight = 120,\n    barOrigin = \"center\",\n    barWidth = 30,\n    participantType,\n  }) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const track: MediaStreamTrack | null = usePipecatClientMediaTrack(\n      \"audio\",\n      participantType\n    );\n\n    useEffect(() => {\n      if (!canvasRef.current) return;\n\n      const canvasWidth = barCount * barWidth + (barCount - 1) * barGap;\n      const canvasHeight = barMaxHeight;\n\n      const canvas = canvasRef.current;\n\n      const scaleFactor = 2;\n\n      // Make canvas fill the width and height of its container\n      const resizeCanvas = () => {\n        canvas.width = canvasWidth * scaleFactor;\n        canvas.height = canvasHeight * scaleFactor;\n\n        canvas.style.width = `${canvasWidth}px`;\n        canvas.style.height = `${canvasHeight}px`;\n\n        canvasCtx.lineCap = barLineCap;\n        canvasCtx.scale(scaleFactor, scaleFactor);\n      };\n\n      const canvasCtx = canvas.getContext(\"2d\")!;\n      resizeCanvas();\n\n      if (!track) return;\n\n      const audioContext = new AudioContext();\n      const source = audioContext.createMediaStreamSource(\n        new MediaStream([track])\n      );\n      const analyser = audioContext.createAnalyser();\n\n      analyser.fftSize = 1024;\n\n      source.connect(analyser);\n\n      const frequencyData = new Uint8Array(analyser.frequencyBinCount);\n\n      canvasCtx.lineCap = barLineCap;\n\n      // Create frequency bands based on barCount\n      const bands = Array.from({ length: barCount }, (_, i) => {\n        // Use improved logarithmic scale for better frequency distribution\n        const minFreq = barCount > 20 ? 200 : 80; // Adjust min frequency based on bar count\n        const maxFreq = 10000; // Cover most important audio frequencies\n\n        // Use Mel scale inspired approach for more perceptually uniform distribution\n        // This helps with a large number of bars by placing fewer in the very low range\n        // https://en.wikipedia.org/wiki/Mel_scale\n        const melMin = 2595 * Math.log10(1 + minFreq / 700);\n        const melMax = 2595 * Math.log10(1 + maxFreq / 700);\n        const melStep = (melMax - melMin) / barCount;\n\n        const melValue = melMin + i * melStep;\n        const startFreq = 700 * (Math.pow(10, melValue / 2595) - 1);\n        const endFreq = 700 * (Math.pow(10, (melValue + melStep) / 2595) - 1);\n\n        return {\n          startFreq,\n          endFreq,\n          smoothValue: 0,\n        };\n      });\n\n      const getFrequencyBinIndex = (frequency: number) => {\n        const nyquist = audioContext.sampleRate / 2;\n        return Math.round(\n          (frequency / nyquist) * (analyser.frequencyBinCount - 1)\n        );\n      };\n\n      function drawSpectrum() {\n        analyser.getByteFrequencyData(frequencyData);\n        canvasCtx.clearRect(\n          0,\n          0,\n          canvas.width / scaleFactor,\n          canvas.height / scaleFactor\n        );\n        canvasCtx.fillStyle = backgroundColor;\n        canvasCtx.fillRect(\n          0,\n          0,\n          canvas.width / scaleFactor,\n          canvas.height / scaleFactor\n        );\n\n        let isActive = false;\n\n        const totalBarsWidth =\n          bands.length * barWidth + (bands.length - 1) * barGap;\n        const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2; // Center bars\n\n        const adjustedCircleRadius = barWidth / 2; // Fixed radius for reset circles\n\n        bands.forEach((band, i) => {\n          const startIndex = getFrequencyBinIndex(band.startFreq);\n          const endIndex = getFrequencyBinIndex(band.endFreq);\n          const bandData = frequencyData.slice(startIndex, endIndex);\n          const bandValue =\n            bandData.reduce((acc, val) => acc + val, 0) / bandData.length;\n\n          const smoothingFactor = 0.2;\n\n          if (bandValue < 1) {\n            band.smoothValue = Math.max(\n              band.smoothValue - smoothingFactor * 5,\n              0\n            );\n          } else {\n            band.smoothValue =\n              band.smoothValue +\n              (bandValue - band.smoothValue) * smoothingFactor;\n            isActive = true;\n          }\n\n          const x = startX + i * (barWidth + barGap);\n          // Calculate bar height with a maximum cap\n          const minHeight = 0;\n          const barHeight = Math.max(\n            minHeight,\n            Math.min((band.smoothValue / 255) * barMaxHeight, barMaxHeight)\n          );\n\n          let yTop, yBottom;\n          const canvasHeight = canvas.height / scaleFactor;\n\n          switch (barOrigin) {\n            case \"top\":\n              yTop = adjustedCircleRadius;\n              yBottom = Math.min(\n                adjustedCircleRadius + barHeight,\n                canvasHeight - adjustedCircleRadius\n              );\n              break;\n            case \"bottom\":\n              yBottom = canvasHeight - adjustedCircleRadius;\n              yTop = Math.max(yBottom - barHeight, adjustedCircleRadius);\n              break;\n            case \"center\":\n            default:\n              yTop = Math.max(\n                canvasHeight / 2 - barHeight / 2,\n                adjustedCircleRadius\n              );\n              yBottom = Math.min(\n                canvasHeight / 2 + barHeight / 2,\n                canvasHeight - adjustedCircleRadius\n              );\n              break;\n          }\n\n          if (band.smoothValue > 0) {\n            canvasCtx.beginPath();\n            canvasCtx.moveTo(x + barWidth / 2, yTop);\n            canvasCtx.lineTo(x + barWidth / 2, yBottom);\n            canvasCtx.lineWidth = barWidth;\n            canvasCtx.strokeStyle = barColor;\n            canvasCtx.stroke();\n          } else {\n            drawInactiveCircle(adjustedCircleRadius, barColor, x, yTop);\n          }\n        });\n\n        if (!isActive) {\n          drawInactiveCircles(adjustedCircleRadius, barColor);\n        }\n\n        requestAnimationFrame(drawSpectrum);\n      }\n\n      function drawInactiveCircle(\n        circleRadius: number,\n        color: string,\n        x: number,\n        y: number\n      ) {\n        switch (barLineCap) {\n          case \"square\":\n            canvasCtx.fillStyle = color;\n            canvasCtx.fillRect(\n              x + barWidth / 2 - circleRadius,\n              y - circleRadius,\n              circleRadius * 2,\n              circleRadius * 2\n            );\n            break;\n          case \"round\":\n          default:\n            canvasCtx.beginPath();\n            canvasCtx.arc(x + barWidth / 2, y, circleRadius, 0, 2 * Math.PI);\n            canvasCtx.fillStyle = color;\n            canvasCtx.fill();\n            canvasCtx.closePath();\n            break;\n        }\n      }\n\n      function drawInactiveCircles(circleRadius: number, color: string) {\n        const totalBarsWidth =\n          bands.length * barWidth + (bands.length - 1) * barGap;\n        const startX = (canvas.width / scaleFactor - totalBarsWidth) / 2;\n        const canvasHeight = canvas.height / scaleFactor;\n\n        let y;\n        switch (barOrigin) {\n          case \"top\":\n            y = circleRadius;\n            break;\n          case \"bottom\":\n            y = canvasHeight - circleRadius;\n            break;\n          case \"center\":\n          default:\n            y = canvasHeight / 2;\n            break;\n        }\n\n        bands.forEach((_, i) => {\n          const x = startX + i * (barWidth + barGap);\n          drawInactiveCircle(circleRadius, color, x, y);\n        });\n      }\n\n      drawSpectrum();\n\n      // Handle resizing\n      window.addEventListener(\"resize\", resizeCanvas);\n\n      return () => {\n        audioContext.close();\n        window.removeEventListener(\"resize\", resizeCanvas);\n      };\n    }, [\n      backgroundColor,\n      barColor,\n      barCount,\n      barGap,\n      barLineCap,\n      barMaxHeight,\n      barOrigin,\n      barWidth,\n      track,\n    ]);\n\n    return (\n      <canvas\n        ref={canvasRef}\n        style={{\n          display: \"block\",\n          width: \"100%\",\n          height: \"100%\",\n        }}\n      />\n    );\n  }\n);\n\nVoiceVisualizer.displayName = \"VoiceVisualizer\";\n"],
  "mappings": "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",
  "names": ["atom", "atom", "atom", "isPromiseLike", "React", "atom", "atom", "import_react", "$h9lXz$createContext", "$h9lXz$useContext", "$h9lXz$useEffect", "$h9lXz$useState", "$h9lXz$useCallback", "$h9lXz$jsx", "$h9lXz$useRef", "track", "trackType", "atom", "$h9lXz$Fragment", "$h9lXz$useContext", "$h9lXz$useCallback", "$h9lXz$jsx", "$h9lXz$Fragment", "$h9lXz$useCallback", "$h9lXz$forwardRef", "$h9lXz$useRef", "$h9lXz$useEffect", "video", "$h9lXz$jsx", "availableCams", "availableMics", "availableSpeakers", "$h9lXz$useContext", "$h9lXz$react", "canvasHeight"]
}
